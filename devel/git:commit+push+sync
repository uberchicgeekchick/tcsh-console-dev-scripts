#!/bin/tcsh -f
set exit_code=0;

set sync_method = "no-sync";
if( -e "./.sync.default" ) set sync_method=`cat ./.sync.default`;

if( -e ./.no.pushing ) set no_pushing;

set log_dir="./.`basename '${0}'`.logs";
set project="`basename '${cwd}'`";
if(! ${?eol} ) setenv eol='$';

set follow_symlinks;
while ( "${1}" != "" )
	set option="`echo "\""${1}"\"" | sed 's/^\-\-\([^=]*\)=\?['\''"\""]\?\(.*\)['\''"\""]\?${eol}/\1/'`";
	set value="`echo "\""${1}"\"" | sed 's/^\-\-\([^=]*\)=\?['\''"\""]\?\(.*\)['\''"\""]\?${eol}/\2/'`";
	#echo "--${option}=${value}";
	switch ( "${option}" )
	case "help":
		goto usage;
		breaksw;
	case "sync":
		set sync_method="${value}";
		breaksw;
	case "no-pushing":
		set no_pushing;
		breaksw;
	case "disable-logging":
		set rm_log;
		breaksw;
	case "skip-remote-clean-up":
		set skip_remote_clean_up;
		breaksw;
	case "branch":
		set branch="${value}";
		breaksw;
	
	case "follow-sysmlinks":
		switch("${value}")
			case "enable":
				if(! ${?follow_symlinks} ) set follow_symlinks;
				breaksw;
		
			case "disable":
				if( ${?follow_symlinks} ) unset follow_symlinks;
				breaksw;
		endsw
		breaksw;
	case "append":
		if( ! -d "${log_dir}" ) then
			printf("No previous commit messages could be found.  I new commit will be created.");
			breaksw;
		endif
		set commit_log=`ls --width=1 ${log_dir} | tail -1`;
		set commit_log="${log_dir}/${commit_log}";

		if( ! -e "${commit_log}" ) then
			set commit_action="Committed";
			printf("No previous commit messages could be found.  I new commit will be created.");
		else
			set commit_action="Commit Appended";
		endif
		breaksw;
	default:
		# git:commit+push+sync logs are stored & saved;
		# Mustly its until I decide how & if I want to;
		# impliment a way of using git's append commits.;
		if( ! ${?commit_log} ) then
			if( ! -d ${log_dir} ) then
				set log_dir_is_new;
				mkdir -p "${log_dir}";
			endif
			set commit_log="${log_dir}/`date '+%Y-%m-%d @ %T'`.message";
			set commit_action="Committed";
			printf "${1}" > "${commit_log}";
			breaksw;
		endif
		printf "\n\n${1}" >> "${commit_log}";
		breaksw;
	endsw
	shift
end
#exit;

if(! ${?commit_log} ) then
	if( -d "${log_dir}" ) then
		set commit_log=`ls --width=1 ${log_dir} | tail -1`;
		set commit_log="${log_dir}/${commit_log}";
	endif
	if(! ${?commit_action} ) set commit_action="Commit Appended";
else
	if(! ${?commit_action} ) set commit_action="Committed";
endif

if(!(${?commit_log} && "${commit_log}" != "" && -e "${commit_log}")) then
	set exit_code = -1;
	goto usage;
endif

printf "\n\n%s on : %s\n" "${commit_action}" "`date '+%Y-%m-%d @ %r'`" >> "${commit_log}";
unset commit_action;

if( ${?follow_symlinks} ) then
	set symlink_log="./.symlink.`date '+%s'`.lst";
	find . -type l -printf '%p\t=\t%l\n' > "${symlink_log}";
	
	set symlink_count="`cat '${symlink_log}'`";
	if(!( ${#symlink_count} > 0 )) then
		rm "${symlink_log}";
		unset symlink_log follow_symlinks;
	else
		
		printf "Following symlinks.\n";
		
		foreach project_symlink("`cat '${symlink_log}'`")
			set target="`echo "\""${project_symlink}"\"" | sed -r 's/(.*)\t\=\t(.*)\/?${eol}/\2/'`";
			set symlink="`echo "\""${project_symlink}"\"" | sed -r 's/(.*)\t\=\t(.*)\/?${eol}/\1/'`";
			
			if(!( "${target}" != "" && "${target}" != "${project_symlink}" && "${symlink}" != "" && "${symlink}" != "${project_symlink}" )) then
				printf "**error** Cannot follow the symlink for %s\n" "${project_symlink}";
				unset target symlink;
				continue;
			endif
			
			#echo "${symlink} points to ${target}";
			cd `dirname "${symlink}"`;
			rm -r ./`basename "${symlink}"`;
			if(! -e ./`basename "${symlink}"` ) cp -r "${target}" ./`basename "${symlink}"`;
			
			cd "${owd}";
			
			unset target symlink;
		end
		
		unset project_symlink;
	endif
endif

git add .;

if( ${?follow_symlinks} && ${?symlink_log} ) then
	if( -e "${symlink_log}" ) git  rm --cached --quiet "${symlink_log}";
endif

# The next;
# Remove any vim, connectED, gedit, or etc 'swp' files.;
# This is even more useful to keep from committing early art works & uber-alphas;
#;
foreach tarball ( "`find . -iregex '.*\.tar\.\(bz2\|gz\)'`" )
	set tarball = "`printf '${tarball}' | sed 's/^\.\///'`";
	git rm -r --cached --quiet "${tarball}";
end
unset tarball;

foreach swp ( "`find . -iregex '.*\.\(sw.\|dev\|art\|bck\|zip\|~\|o\)'`" )
	set swp = "`printf '${swp}' | sed 's/^\.\///'`";
	git rm -r --cached --quiet "${swp}";
end
unset swp;

foreach art ( "`find . -iregex '.*\.\(art\|dev\|ref\|new\|old\)\.[^\.]*'`" )
	set art = "`printf '${art}' | sed 's/^\.\///'`";
	git rm -r --cached --quiet "${art}";
end
unset art;

git rm -r --cached --quiet "${log_dir}";

if(! ${?branch} ) then
	set branch="`head -1 '${commit_log}'`";
	if(! -e ".git/refs/heads/${branch}" ) unset branch;
	#if( `/bin/ls ".git/refs/heads/${branch}"` == "" ) unset branch;
else if( ${?branch} ) then
	if( "`head -1 '${commit_log}'`" != "${branch}" ) then
		printf "${branch}\n\n" > "${commit_log}.swp";
		cat "${commit_log}" >> "${commit_log}.swp";
		mv "${commit_log}.swp" "${commit_log}";
	endif
endif

git commit -a -F "${commit_log}" --cleanup=verbatim;

if( ${?rm_log} ) then
	rm "${commit_log}";
	if( ${?log_dir_is_new} ) rmdir "${log_dir}";
endif

#foreach test_branch("`/bin/ls --width=1 -tr .git/refs/heads/ | tail -2 | sed 's/[\r\n]//'`")
#	if( "${test_branch}" != "" && "${test_branch}" != "master" ) then
#		set branch=${test_branch};
#	endif
#end

if( ${?branch} ) then
	printf "Updating %s's branch: %s\n" "${project}" "${branch}";
	git branch -f "${branch}";
endif

if( ${?follow_symlinks} && ${?symlink_log} ) then
	if( -e "${symlink_log}" ) then
		
		printf "Restoring symlinks.\n";
		
		foreach project_symlink("`cat '${symlink_log}'`")
			set target="`echo "\""${project_symlink}"\"" | sed -r 's/(.*)\t\=\t(.*)\/?${eol}/\2/'`";
			set symlink="`echo "\""${project_symlink}"\"" | sed -r 's/(.*)\t\=\t(.*)\/?${eol}/\1/'`";
			
			if(!( "${target}" != "" && "${target}" != "${project_symlink}" && "${symlink}" != "" && "${symlink}" != "${project_symlink}" )) then
				printf "**error** Cannot follow the symlink for %s\n" "${project_symlink}";
				unset target symlink;
				continue;
			endif
			
			cd `dirname "${symlink}"`;
			rm -rf ./`basename "${symlink}"`;
			if(! -e ./`basename "${symlink}"` ) ln -sf "${target}" ./`basename "${symlink}"`;
			
			cd "${owd}";
			
			unset target symlink;
		end
		
		rm -f "${symlink_log}" > /dev/null;
		unset project_symlink follow_symlinks symlink_log;
	endif
endif

if(! ${?no_pushing} ) then
	foreach remote_git ( "`git remote`" )
		if( ${?branch} ) then
			git push "${remote_git}" "${branch}"
		endif
		git push "${remote_git}" master;
	end
endif


exit;


goto check_sync;
exit;

init_sync:
set project_name = "`basename '${cwd}'`";
set sshfs_path = "/projects/ssh";
set ssh_user = "dreams";
set ssh_server = "sky.ocssolutions.com";


run_sync:
switch( "${sync_method}" )
case "rsync":
	rsync -r --verbose ./* "${ssh_user}@${ssh_server}:/home/${ssh_user}/${project_name}";
	breaksw;

case "scp":
	scp -rv ./* "${ssh_user}@${ssh_server}:/home/${ssh_user}/${project_name}";
	breaksw;

case "sshfs":
	if( `mount | grep "${sshfs_path}"` == "" ) then
		sshfs "${ssh_user}@${ssh_server}:/home/${ssh_user}" "${sshfs_path}";
	endif
case "cp":
	if( ! -d "${sshfs_path}/${project_name}" ) then
		printf "I couldn't find your project: '%s' in your sshfs path: '%s'\nEither your project doesn't exist on your sshfs or ssh isn't mounted\n", ${project_name}, ${sshfs_path};
		exit;
	endif
	
	printf "\n\nI am now copying new and/or modified files.\nTo update this project's remote location.\nThis may also take several moments.\n\n";
	cp -r --verbose --update --no-dereference ./* "${sshfs_path}/${project_name}";
	printf "\t\t[done]";
	
	# cleaning up swp files that may have been copied to the remote location
	printf "\n\tI'm now removing any swap or back-up files that may have been copied.\n";
	foreach swp ( "`find '${sshfs_path}/${project_name}' -iregex '.*\.\(sw.\|~\)'`" )
		rm --verbose "${swp}";
	end
	printf "\t\t[done]";
	
stale_check:
	goto script_exit_clean;
	if( ${?skip_remote_clean_up} ) breaksw;
		
	# compare "${sshfs_path}/${project_name}/" against ./;
	# and remove remote files that no longer exist locally.;
	printf "\n\nFinding all remote files to check for stale files and directories.\nPlease be patient as this may take a few moments.\n";
	set remove_remote_regexp = "`printf "\""${sshfs_path}/${project_name}/"\"" | sed 's/\//\\\//g'`";
	foreach remote_file ( "`find "\""${sshfs_path}/${project_name}/"\""*`" )
		# escape special characters to keep them from being expanded by the terminal;
		# set remote_file = "`printf '${remote_file}' | sed 's/\([\.\*\[\]()]\)/\\\1/g' | sed 's/\('\''\)/\1\\\1\1/g'`";
		
		set git_test = "`printf "\""${remote_file}"\"" | sed 's/.*\(\/\.git\).*/\1/g'`";
		if( "${git_test}" == "/.git" ) continue;
		
		set local_file = "`printf "\""${remote_file}"\"" | sed 's/^${remove_remote_regexp}/\.\//'`";
		
		if( -d "${local_file}" || -e "${local_file}" ) continue;
		
		printf "\t[remote] '%s' appears to be a stale " "${remote_file}";
		
		if( -d "${remote_file}" ) then
			printf "directory";
			rm -r "${remote_file}";
			else if( -e "${remote_file}" ) then
				printf "file";
				rm "${remote_file}";
			endif
			printf "\t[removed]\n";
		end
	
	printf "\nRemoving stale remote files\t\t[done]";
	
	breaksw;
endsw

script_exit_clean:
	exit 0;

script_exit_fail:
	if( ! ${?exit_error} ) set exit_error="-1";
	exit ${exit_error};

check_sync:
switch ( "${sync_method}" )
case "rsync":
case "scp":
case "sshfs":
case "cp":
	goto init_sync;
	breaksw;
case "no-sync":
	exit ${exit_code};
	breaksw;
default:
	printf "%s is not a supported sync method.  Valid options are:\n\trsync, scp, sshfs, cp, no-sync" "${sync_method}";
	exit -2;
	breaksw;
endsw

usage:
printf "Usage: %s\n\t--help\t Displays this message.\n\n--current-working-directory=/local/path/to/project's/root/directory\tThis causes %s to cd to the specified path before commiting & syncronizing.\n\n--sync=[rsync, scp, sshfs, cp, no-sync]\tControls how files are copied or backed-up.  Especially useful for online based projects.  The project's default sync method may be set by creating a file named './.sync.default'.\n\n\t--no-pushing\tSkips git's 'remote push for this commit.\n\n--skip-remote-clean-up\tThis stops %s from comfirming all remote files still exist locally, under your current working directory.\nThis is specifically useful if your project has files which use special characters.\nThe recommanded usage for this feature is to run the script 1st w/o this flag & than run a second sync using this flag.  But just an idea not a requirement or any thing.\n\n--disable-logging\tKeeps %s from preserving this commit message.\n\n--append\tappends, or re-commits, any changes using the previously logged commit message commit_message [commit_details]\n" `basename "${0}"` `basename "${0}"` `basename "${0}"`;
exit ${exit_code};

