#!/bin/tcsh -f

set status=0;

set git_commit_setting_files=( "sync.default" "no.pushing" "no.logging" );

if(! -e "./.sync.default" ) then
	set sync_method = "no-sync";
else
	set sync_method=`cat ./.sync.default`;
endif

if(! -e ./.no.pushing ) set push;
if(! -e ./.no.logging ) set logging;

set old_owd="${owd}";
set old_cwd="${cwd}";
while( "${cwd}" != "/" && ! -d "./.git" )
	cd ..;
	if(! -d "./.git" ) continue;
	set git_dir="${cwd}";
	break;
end

if(! ${?git_dir} ) then
	cd "${old_cwd}";
	set owd="${old_owd}";
	unset old_owd;
	unset old_cwd;
endif

set log_dir="./.`basename '${0}'`.logs";
set project="`basename '${cwd}'`";
if(! ${?eol} ) setenv eol='$';

@ argc=0
while ( "$argv[$argc]" != "" )
	if( "$argv[$argc]" == "--debug" )
		set debug_commit;
		break;
	endif
	@ argc++;
end

set follow_symlinks;
while ( "${1}" != "" )
	set option="`printf '%s' "\""${1}"\"" | sed 's/^\-\-\([^=]*\)=\?['\''"\""]\?\(.*\)['\''"\""]\?${eol}/\1/'`";
	set value="`printf '%s' "\""${1}"\"" | sed 's/^\-\-\([^=]*\)=\?['\''"\""]\?\(.*\)['\''"\""]\?${eol}/\2/'`";
	if( ${?debug_commit} ) printf 'Parsing Option:\n\t--%s=%s\n' "${option}" "${value}";
	switch ( "${option}" )
	case "help":
		goto usage;
		breaksw;
	case "sync":
		set sync_method="${value}";
		breaksw;
	case "no-push":
	case "no-pushing":
		if( ${?push} ) unset push;
		breaksw;
	case "push-to":
		if( "${value}" != "" ) then
			foreach git_repo("`git remote`")
				if("${value}" == "${git_repo}") then
					set push_to="${value}";
					break;
				endif
			end
		endif
		if(! ${?push_to} ) then
			printf "%s is not a valid remote git repo.\n" "${value}" > /dev/stderr;
		else
			set push="${push_to}";
			unset push_to;
		endif
		breaksw;
	case "skip-remote-clean-up":
		set skip_remote_clean_up;
		breaksw;
	case "branch":
		set branch="${value}";
		breaksw;
	case "append":
		if( ! -d "${log_dir}" ) then
			printf "No previous commit messages could be found.  I new commit will be created.";
			breaksw;
		endif
		set commit_log=`ls --width=1 ${log_dir} | tail -1`;
		set commit_log="${log_dir}/${commit_log}";

		if( ! -e "${commit_log}" ) then
			set commit_action="Committed";
			printf "No previous commit messages could be found.  I new commit will be created.";
		else
			set commit_action="Commit Appended";
		endif
		breaksw;
	case "follow-sysmlinks":
		switch("${value}")
			case "disable":
				if( ${?follow_symlinks} ) unset follow_symlinks;
				breaksw;
			case "enable":
			default:
				if(! ${?follow_symlinks} ) set follow_symlinks;
				breaksw;
		endsw
		breaksw;
	case "enable":
		switch("${value}")
			case "follow-sysmlinks":
				if(! ${?follow_symlinks} ) set follow_symlinks;
				breaksw;
			case "push":
				if(! ${?push} ) set push;
				breaksw;
			case "logging":
				if(! ${?logging} ) set logging;
				breaksw;
		endsw
		breaksw;
	case "disable":
		switch("${value}")
			case "follow-sysmlinks":
				if( ${?follow_symlinks} ) unset follow_symlinks;
				breaksw;
			case "push":
				if( ${?push} ) unset push;
				breaksw;
			case "logging":
				if( ${?logging} ) unset logging;
				breaksw;
		endsw
		breaksw;
	default:
		# git:commit+push+sync logs are stored & saved;
		# Mustly its until I decide how & if I want to;
		# impliment a way of using git's append commits.;
		if( ! ${?commit_log} ) then
			if( ! -d ${log_dir} ) then
				set log_dir_is_new;
				mkdir -p "${log_dir}";
			endif
			set commit_log="${log_dir}/`date '+%Y-%m-%d @ %T'`.message";
			set commit_action="Committed";
		else
			printf '\n\n' > "${commit_log}";
		endif
		printf '%s' "${1}" >> "${commit_log}";
		breaksw;
	endsw
	shift;
end

if( ${?debug_commit} ) printf "Option parsing complete.\n";

if(! ${?commit_log} ) then
	if( -d "${log_dir}" ) then
		set commit_log=`ls --width=1 ${log_dir} | tail -1`;
		set commit_log="${log_dir}/${commit_log}";
	endif
	if(! ${?commit_action} ) set commit_action="Commit Appended";
else
	if(! ${?commit_action} ) set commit_action="Committed";
endif

if(!(${?commit_log} && "${commit_log}" != "" && -e "${commit_log}")) then
	set status=-1;
	goto usage;
endif

printf "\n\n%s on : %s\n" "${commit_action}" "`date '+%Y-%m-%d @ %r'`" >> "${commit_log}";
unset commit_action;

if( ${?follow_symlinks} ) then
	set symlink_log="./.symlink.`date '+%s'`.lst";
	find . -type l -printf '%p\t=\t%l\n' > "${symlink_log}";
	
	set symlink_count="`cat '${symlink_log}'`";
	if(!( ${#symlink_count} > 0 )) then
		rm "${symlink_log}";
		unset symlink_log follow_symlinks;
	else
		
		printf "Following symlinks.\n";
		
		foreach project_symlink("`cat '${symlink_log}'`")
			set target="`printf '%s' "\""${project_symlink}"\"" | sed -r 's/(.*)\t\=\t(.*)\/?${eol}/\2/'`";
			set symlink="`printf '%s' "\""${project_symlink}"\"" | sed -r 's/(.*)\t\=\t(.*)\/?${eol}/\1/'`";
			
			if(!( "${target}" != "" && "${target}" != "${project_symlink}" && "${symlink}" != "" && "${symlink}" != "${project_symlink}" )) then
				printf "**error** Cannot follow the symlink for %s\n" "${project_symlink}";
				unset target symlink;
				continue;
			endif
			
			#printf '%s points to %s\n' "${symlink}" "${target}";
			cd `dirname "${symlink}"`;
			rm -r ./`basename "${symlink}"`;
			if(! -e ./`basename "${symlink}"` ) cp -r "${target}" ./`basename "${symlink}"`;
			
			cd "${owd}";
			
			unset target symlink;
		end
		
		unset project_symlink;
	endif
endif

git add .;

if( ${?follow_symlinks} && ${?symlink_log} ) then
	if( -e "${symlink_log}" ) git  rm --cached --quiet "${symlink_log}";
endif

# Keep extremely large files from being committed;
set extensions="bz2\|gz\|tgz\|zip";
foreach tarball ( "`find . -iregex '.*\.\(${extensions}\)' | sed -r 's/(.*)\.(${extensions})([^\/]*).*/\1\.\2\3/' | uniq`" )
	if( "`printf '%s' '${tarball}' | sed 's/^\(\.git\).*/\1/'`" == ".git" ) continue;
	set tarball = "`printf '${tarball}' | sed 's/^\.\///'`";
	git rm -r --cached --quiet "${tarball}";
end
unset tarball;

# Remove any vim, connectED, gedit, or etc 'swp' files.;
set extensions="sw.\|bck\|~\|o";
foreach swp ( "`find . -iregex '.*\.\(${extensions}\)' | sed -r 's/(.*)\.(${extensions})([^\/]*).*/\1\.\2\3/' | uniq`" )
	if( "`printf '%s' '${swp}' | sed 's/^\(\.git\).*/\1/'`" == ".git" ) continue;
	set swp = "`printf '${swp}' | sed 's/^\.\///'`";
	git rm -r --cached --quiet "${swp}";
end
unset swp;

# Don't commit early art works, uber-alpha code, & ald works;
set extensions="art\|dev\|ref\|new\|old";
foreach art ( "`find . -iregex '.*[\.\-]\(${extensions}\).*' | sed 's/\(.*\)\([\.\-]\)\(${extensions}\)\([^\/]*\).*/\1\2\3\4/' | uniq`" )
	if( "`printf '%s' '${art}' | sed 's/^\(\.git\).*/\1/'`" == ".git" ) continue;
	set art = "`printf '${art}' | sed 's/^\.\///'`";
	git rm -r --cached --quiet "${art}";
end
unset art;

unset extensions;

# Keep my logs from being added to any commit.
foreach git_commit_setting_file( ${git_commit_setting_files} )
	if( -e "./.${git_commit_setting_file}" ) git rm --cached --quiet "./.${git_commit_setting_file}";
end
unset git_commit_setting_file git_commit_setting_files;

git rm -r --cached --quiet "${log_dir}";

if(! ${?branch} ) then
	set branch="`head -1 '${commit_log}'`";
	if(! -e ".git/refs/heads/${branch}" ) unset branch;
	#if( `/bin/ls ".git/refs/heads/${branch}"` == "" ) unset branch;
else if( ${?branch} ) then
	if( "`head -1 '${commit_log}'`" != "${branch}" ) then
		printf "${branch}\n\n" > "${commit_log}.swp";
		cat "${commit_log}" >> "${commit_log}.swp";
		rm "${commit_log}";
		mv "${commit_log}.swp" "${commit_log}";
	endif
endif

git commit -a -F "${commit_log}" --cleanup=verbatim;

if(! ${?logging} ) then
	rm "${commit_log}";
	if( ${?log_dir_is_new} ) rmdir "${log_dir}";
endif

if( ${?branch} ) then
	printf "Updating %s's branch: %s\n" "${project}" "${branch}";
	git branch -f "${branch}";
endif

#foreach newwest_branch("`/bin/ls --width=1 -tr .git/refs/heads/ | tail -2 | sed 's/[\r\n]//'`")
#	if( "${newwest_branch}" != "" && "${newwest_branch}" != "${branch}" && "${newwest_branch}" != "master" ) then
#		set branch -f "${newest_branch}";
#	endif
#end

if( ${?follow_symlinks} && ${?symlink_log} ) then
	if( -e "${symlink_log}" ) then
		
		printf "Restoring symlinks.\n";
		
		foreach project_symlink("`cat '${symlink_log}'`")
			set target="`printf '%s' "\""${project_symlink}"\"" | sed -r 's/(.*)\t\=\t(.*)\/?${eol}/\2/'`";
			set symlink="`printf '%s' "\""${project_symlink}"\"" | sed -r 's/(.*)\t\=\t(.*)\/?${eol}/\1/'`";
			
			if(!( "${target}" != "" && "${target}" != "${project_symlink}" && "${symlink}" != "" && "${symlink}" != "${project_symlink}" )) then
				printf "**error** Cannot follow the symlink for %s\n" "${project_symlink}";
				unset target symlink;
				continue;
			endif
			
			cd `dirname "${symlink}"`;
			rm -rf ./`basename "${symlink}"`;
			if(! -e ./`basename "${symlink}"` ) ln -sf "${target}" ./`basename "${symlink}"`;
			
			cd "${owd}";
			
			unset target symlink;
		end
		
		rm -f "${symlink_log}" > /dev/null;
		unset project_symlink follow_symlinks symlink_log;
	endif
endif

if( ${?push} ) then
	foreach remote_git_repo ( "`git remote`" )
		if( "${push}" != "" && "${push}" != "${remote_git_repo}" ) continue;
		if( ${?branch} ) then
			git push "${remote_git_repo}" "${branch}"
		endif
		git push "${remote_git_repo}" master;
	end
endif


goto check_sync;

exit_script:
	if( ${?old_cwd} ) then
		cd "${old_cwd}";
		set owd="${old_owd}";
		unset old_owd;
		unset old_cwd;
	endif
	exit ${status};

sync:
	set project_name = "`basename '${cwd}'`";
	set sshfs_path = "/projects/ssh";
	set ssh_user = "dreams";
	set ssh_server = "sky.ocssolutions.com";

	switch( "${sync_method}" )
	case "rsync":
		if(! ${?skip_remote_clean_up} ) set skip_remote_clean_up;
		rsync -r --verbose ./* "${ssh_user}@${ssh_server}:/home/${ssh_user}/${project_name}";
		breaksw;
	
	case "scp":
		if(! ${?skip_remote_clean_up} ) set skip_remote_clean_up;
		scp -rv ./* "${ssh_user}@${ssh_server}:/home/${ssh_user}/${project_name}";
		breaksw;
	
	case "sshfs":
		if( `mount | grep "${sshfs_path}"` == "" ) then
			sshfs "${ssh_user}@${ssh_server}:/home/${ssh_user}" "${sshfs_path}";
		endif
	case "cp":
		if( ! -d "${sshfs_path}/${project_name}" ) then
			printf "I couldn't find your project: '%s' in your sshfs path: '%s'\nEither your project doesn't exist on your sshfs or ssh isn't mounted\n", ${project_name}, ${sshfs_path};
			set status=-3;
			goto exit_script;
		endif
		
		printf "\n\nI am now copying new and/or modified files.\nTo update this project's remote location.\nThis may also take several moments.\n\n";
		cp -r --verbose --update --no-dereference ./* "${sshfs_path}/${project_name}";
		printf "\t\t[done]";
	
		# cleaning up swp files that may have been copied to the remote location
		printf "\n\tI'm now removing any swap or back-up files that may have been copied.\n";
		foreach swp ( "`find '${sshfs_path}/${project_name}' -iregex '.*\.\(sw.\|~\)'`" )
			rm --verbose "${swp}";
		end
		printf "\t\t[done]";
		breaksw;
	endsw
#sync

remote_clean_up:
	goto exit_script;
	if( ${?skip_remote_clean_up} ) goto exit_script;
		
	# compare "${sshfs_path}/${project_name}/" against ./;
	# and remove remote files that no longer exist locally.;
	printf "\n\nFinding all remote files to check for stale files and directories.\nPlease be patient as this may take a few moments.\n";
	set remove_remote_regexp = "`printf "\""${sshfs_path}/${project_name}/"\"" | sed 's/\//\\\//g'`";
	foreach remote_file ( "`find "\""${sshfs_path}/${project_name}/"\""*`" )
		# escape special characters to keep them from being expanded by the terminal;
		# set remote_file = "`printf '${remote_file}' | sed 's/\([\.\*\[\]()]\)/\\\1/g' | sed 's/\('\''\)/\1\\\1\1/g'`";
		
		set git_test = "`printf "\""${remote_file}"\"" | sed 's/.*\(\/\.git\).*/\1/g'`";
		if( "${git_test}" == "/.git" ) continue;
		
		set local_file = "`printf "\""${remote_file}"\"" | sed 's/^${remove_remote_regexp}/\.\//'`";
		
		if( -d "${local_file}" || -e "${local_file}" ) continue;
		
		printf "\t[remote] '%s' appears to be a stale " "${remote_file}";
		
		if( -d "${remote_file}" ) then
			printf "directory";
			rm -r "${remote_file}";
			else if( -e "${remote_file}" ) then
				printf "file";
				rm "${remote_file}";
			endif
			printf "\t[removed]\n";
		end
	
	printf "\nRemoving stale remote files\t\t[done]";
#remote_clean_up

check_sync:
	switch ( "${sync_method}" )
		case "rsync":
		case "scp":
		case "sshfs":
		case "cp":
			goto sync;
			breaksw;
		case "no-sync":
			goto exit_script;
			breaksw;
		default:
			printf "%s is not a supported sync method.  Valid options are:\n\trsync, scp, sshfs, cp, no-sync" "${sync_method}";
			set status=-2;
			goto exit_script;
			breaksw;
		endsw
#check_sync

usage:
	printf "Usage: %s\n\t--help\t Displays this message.\n\n--current-working-directory=/local/path/to/project's/root/directory\tThis causes %s to cd to the specified path before commiting & syncronizing.\n\n--sync=[rsync, scp, sshfs, cp, no-sync]\tControls how files are copied or backed-up.  Especially useful for online based projects.  The project's default sync method may be set by creating a file named './.sync.default'.\n\n\t--no-push\tSkips git's 'remote push for this commit.\n\n--skip-remote-clean-up\tThis stops %s from comfirming all remote files still exist locally, under your current working directory.\nThis is specifically useful if your project has files which use special characters.\nThe recommanded usage for this feature is to run the script 1st w/o this flag & than run a second sync using this flag.  But just an idea not a requirement or any thing.\n\n--disable-logging\tKeeps %s from preserving this commit message.\n\n--append\tappends, or re-commits, any changes using the previously logged commit message commit_message [commit_details]\n" `basename "${0}"` `basename "${0}"` `basename "${0}"`;
	goto exit_script;
#usage

