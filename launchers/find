#!/bin/tcsh -f
init:
	if( ${?SSH_CONNECTION} ) then
		set stdout=/dev/null;
		set stderr=/dev/null;
	else
		set stdout=/dev/stdout;
		set stderr=/dev/stdout;
	endif
	
	set supports_being_source;
	set scripts_basename="find";
	
	set escaped_starting_dir="`printf "\""%s"\"" "\""${cwd}"\"" | sed -r 's/\//\\\//g' | sed -r 's/(["\""])/"\""\\"\"""\""/g' | sed -r 's/([*])/\\\1/g' | sed -r 's/(['\!'])/\\\1/g'`";
	set escaped_home_dir="`printf "\""%s"\"" "\""${HOME}"\"" | sed -r 's/\//\\\//g' | sed -r 's/(["\""])/"\""\\"\"""\""/g' | sed -r 's/([*])/\\\1/g' | sed -r 's/(['\!'])/\\\1/g'`";
#init:


check_dependencies:
	set dependencies=("${scripts_basename}");
	@ dependencies_index=0;
	
	while( $dependencies_index < ${#dependencies} )
		@ dependencies_index++;
		set dependency=$dependencies[$dependencies_index];
		#if( ${?debug} ) \
			printf "\n**${scripts_basename} debug:** looking for dependency: ${dependency}; "\$"dependencies[%d].\n\n" $dependencies_index > ${stdout};
			
		foreach exec("`where '${dependency}'`")
			if(! -x "${exec}" ) then
				unset exec;
				continue;
			endif
			
			#if( ${?debug} ) \
				printf "\n**${scripts_basename} debug:** looking for dependency: ${dependency}, "\$"dependencies[%d], against: %s.\n\n" $dependencies_index "${exec}" > ${stdout};
			switch("${exec}")
				case "./${scripts_basename}":
				case "${TCSH_LAUNCHER_PATH}/${scripts_basename}":
					if( ${?scripts_dirname} ) \
						breaksw;
						
					set old_owd="${cwd}";
					cd "`dirname '${exec}'`";
					set scripts_dirname="${cwd}";
					cd "${owd}";
					set owd="${old_owd}";
					unset old_owd;
					set script="${scripts_dirname}/${scripts_basename}";
					unset exec;
					breaksw;
				
				default:
					switch("`basename "\""${exec}"\""`")
						case "find":
							set program="${exec}";
							breaksw;
					endsw
					breaksw;
			endsw
		end
	end
	
	if(! ${?program} ) \
		set program="";
	
	if(! -x "${program}" ) \
		goto missing_dependency;
		
	
	unset dependency dependencies;
#check_dependencies:


if_sourced:
	if( ${?0} ) \
		goto main;
	
	# for exception handeling when this file is 'sourced'.
	
	# BEGIN: disable source scripts_basename.
	if(! ${?supports_being_source} ) then
		set status=-1;
		printf "%s does not support being sourced.\n" "${scripts_basename}";
		goto usage;
	endif
	# END: disable source scripts_basename.
	
	# BEGIN: source scripts_basename support.
	source "${TCSH_RC_SESSION_PATH}/argv:check" "${scripts_basename}" ${argv};
	if( $args_handled > 0 ) then
		@ args_shifted=0;
		while( $args_shifted < $args_handled )
			@ args_shifted++;
			shift;
		end
		unset args_shifted;
	endif
	unset args_handled;
	
	# START: special handler for when this file is sourced.
	alias ${scripts_basename} "${script}";
	# FINISH: special handler for when this file is sourced.
	
	source "${TCSH_RC_SESSION_PATH}/argv:clean-up" "${scripts_basename}";
	
	# END: source scripts_basename support.
	
	goto script_main_quit;
#if_sourced:


main:
	set argc=${#argv};
	if( ${argc} < 1 ) then
		set status=-1;
		goto usage;
	endif
	
	set escaped_cwd="`printf '%s' '${cwd}' | sed -r 's/\//\\\//g'`";
	
	set follow_symlinks="L";
	set regextype="posix-extended"
	
	alias ex "ex -E -n -X --noplugin";
	
	goto parse_argv; # exit's via 'usage:' or 'main:'.
#main:


exec:
	set status=0;
	if(! ${?SURPRESS_STDERR} ) then
		if( ${?debug} ) \
			printf "( %s -%s %s -regextype %s "\""${argz}"\"" > /dev/tty ) >& /dev/stderr;" "${program}" "${follow_symlinks}" "${find_target}" "${regextype}";
		( ${program} -${follow_symlinks} ${find_target} -regextype ${regextype} "${argz}" > /dev/tty ) >& /dev/stderr;
	else
		if( ${?debug} ) \
			printf "( %s -%s %s -regextype %s "\""${argz}"\"" > /dev/tty ) >& /dev/null;" "${program}" "${follow_symlinks}" "${find_target}" "${regextype}";
		( ${program} -${follow_symlinks} ${find_target} -regextype ${regextype} "${argz}" > /dev/tty ) >& /dev/null;
	endif
	goto script_main_quit;
#exec:


script_main_quit:
	if( ${?supports_being_source} ) unset supports_being_source;
	if( ${?scripts_basename} ) unset scripts_basename;
	if( ${?scripts_path} ) unset scripts_path;
	if( ${?script} ) unset script;
	if( ${?escaped_cwd} ) unset escaped_cwd;
	if( ${?dependency} ) unset dependency;
	if( ${?dependencies} ) unset dependencies;
	if( ${?argz} ) unset argz;
	if( ${?debug} ) unset debug;
	if( ${?usage_displayed} ) unset usage_displayed;
	if( ${?no_exit_on_usage} ) unset no_exit_on_usage;
	if( ${?use_old_owd} ) then
		cd "${owd}";
		set owd="${use_old_owd}";
		unset use_old_owd;
	endif
	exit ${status}
#script_main_quit:


missing_dependency:
	printf "One or more required dependencies couldn't be found.\n\n[%s] couldn't be found.\n\n%s requires: %s" "${dependency}" "${scripts_basename}" "${dependencies}";
	set status=-1;
	goto script_main_quit;
#missing_dependency:


usage:
	if(! ${?usage_displayed} ) then
		if( ${?script} ) then
			if( ${?program} ) then
				if( "${program}" != "${script}" ) then
					${program} --help;
					set usage_displayed;
				endif
			endif
		endif
	endif
	
	if(! ${?usage_displayed} ) then
		printf "Usage:\t%s [-h|--help]...\n\t[-h|--help]\tDisplays this screen.\n" "${scripts_basename}";
	endif
	
	if(! ${?usage_displayed} ) set usage_displayed;
	if(! ${?no_exit_on_usage} ) then
		goto script_main_quit;
	endif
	goto parse_arg;
#usage:


parse_argv:
	@ argc=${#argv};
	@ arg=0;
	while( $arg < $argc )
		@ arg++;
		switch("$argv[$arg]")
			case "--diagnosis":
			case "--diagnostic-mode":
				printf "**%s debug:**, via "\$"argv[%d], diagnostic mode\t[enabled].\n\n" "${scripts_basename}" $arg;
				set diagnostic_mode;
				break;
			
			case "--debug":
				printf "**%s debug:**, via "\$"argv[%d], debug mode\t[enabled].\n\n" "${scripts_basename}" $arg;
				set debug;
				break;
			
			default:
				continue;
		endsw
	end
	
	if( ${?debug} || ${?diagnostic_mode} ) \
		printf "**%s debug:** checking argv.  %d total arguments.\n\n" "${scripts_basename}" "${argc}";
	
	@ arg=0;
	@ parsed_argc=0;
#parse_argv:

parse_arg:
	set argz="";
	while( $arg < $argc )
		if(! ${?arg_shifted} ) \
			@ arg++;
		
		if( ${?debug} || ${?diagnostic_mode} ) \
			printf "**%s debug:** Checking argv #%d (%s).\n" "${scripts_basename}" "${arg}" "$argv[$arg]";
		
		set dashes="`printf '$argv[$arg]' | sed -r 's/^([\-]{1,2})([^\=]+)(\=?)(['\''"\""]?)(.*)(['\''"\""]?)"\$"/\1/' | sed -r 's/(["\$"])/"\""\\"\$""\""/g'`";
		if( "${dashes}" == "$argv[$arg]" ) \
			set dashes="";
		
		set option="`printf '$argv[$arg]' | sed -r 's/^([\-]{1,2})([^\=]+)(=?)(['\''"\""]?)(.*)(['\''"\""]?)"\$"/\2/' | sed -r 's/["\$"]/"\""\\"\$""\""/g'`";
		if( "${option}" == "$argv[$arg]" ) \
			set option="";
		
		set equals="`printf '$argv[$arg]' | sed -r 's/^([\-]{1,2})([^\=]+)(=?)(['\''"\""]?)(.*)(['\''"\""]?)"\$"/\3/' | sed -r 's/["\$"]/"\""\\"\$""\""/g'`";
		if( "${equals}" == "$argv[$arg]" ) \
			set equals="";
		
		set quotes="`printf '$argv[$arg]' | sed -r 's/^([\-]{1,2})([^\=]+)(=?)(['\''"\""]?)(.*)(['\''"\""]?)"\$"/\4/' | sed -r 's/["\$"]/"\""\\"\$""\""/g'`";
		if( "${quotes}" == "$argv[$arg]" ) \
			set quotes="";
		
		#set equals="";
		set value="`printf '$argv[$arg]' | sed -r 's/^([\-]{1,2})([^\=]+)(=?)(['\''"\""]?)(.*)(['\''"\""]?)"\$"/\5/' | sed -r 's/["\$"]/"\""\\"\$""\""/g'`";
		#if( "${value}" != "" && "${value}" != "$argv[$arg]" ) then
		#	set equals="=";
		#else if( "${option}" != "" ) then
		if( "${option}" != "$argv[$arg]" && "${equals}" == "" && ( "${value}" == "" || "${value}" == "$argv[$arg]" ) ) then
			@ arg++;
			if( ${arg} > ${argc} ) then
				@ arg--;
			else
				set test_dashes="`printf '$argv[$arg]' | sed -r 's/^([\-]{1,2})([^\=]+)(=?)(['\''"\""]?)(.*)(['\''"\""]?)"\$"/\1/' | sed -r 's/["\$"]/"\""\\"\$""\""/g'`";
				set test_option="`printf '$argv[$arg]' | sed -r 's/^([\-]{1,2})([^\=]+)(=?)(['\''"\""]?)(.*)(['\''"\""]?)"\$"/\2/' | sed -r 's/["\$"]/"\""\\"\$""\""/g'`";
				set test_equals="`printf '$argv[$arg]' | sed -r 's/^([\-]{1,2})([^\=]+)(=?)(['\''"\""]?)(.*)(['\''"\""]?)"\$"/\3/' | sed -r 's/["\$"]/"\""\\"\$""\""/g'`";
				set test_quotes="`printf '$argv[$arg]' | sed -r 's/^([\-]{1,2})([^\=]+)(=?)(['\''"\""]?)(.*)(['\''"\""]?)"\$"/\4/' | sed -r 's/(["\$"])/"\""\\"\$""\""/g'`";
				set test_value="`printf '$argv[$arg]' | sed -r 's/^([\-]{1,2})([^\=]+)(=?)(['\''"\""]?)(.*)(['\''"\""]?)"\$"/\5/' | sed -r 's/["\$"]/"\""\\"\$""\""/g'`";# | sed -r 's/["\$"]/"\""\\"\$""\""/g' | sed -r 's/^\ //' | sed -r 's/(["\""])/"\""\\"\"""\""/g' | sed -r 's/([*])/\\\1/g' | sed -r 's/(['\!'])/\\\1/g' | sed -r 's/(\[)/\\\1/g'`";
				
				if( ${?debug} || ${?diagnostic_mode} ) \
					printf "\tparsed %sargv[%d] (%s) to test for replacement value.\n\tparsed %stest_dashes: [%s]; %stest_option: [%s]; %stest_equals: [%s]; %stest_quotes: [%s]; %stest_value: [%s]\n" \$ "${arg}" "$argv[$arg]" \$ "${test_dashes}" \$ "${test_option}" \$ "${test_equals}" \$ "${test_quotes}" \$ "${test_value}";
				
				if(!("${test_dashes}" == "$argv[$arg]" && "${test_option}" == "$argv[$arg]" && "${test_equals}" == "$argv[$arg]" && "${test_value}" == "$argv[$arg]")) then
					@ arg--;
				else
					set equals=" ";
					set value="${test_value}";#"`printf "\""%s"\"" "\""$argv[$arg]"\"" | sed -r 's/["\$"]/"\""\\"\$""\""/g' | sed -r 's/^\ //' | sed -r 's/(["\""])/"\""\\"\"""\""/g' | sed -r 's/([*])/\\\1/g' | sed -r 's/(['\!'])/\\\1/g' | sed -r 's/(\[)/\\\1/g'`";
					set arg_shifted;
				endif
				unset test_dashes test_option test_equals test_value;
			endif
		endif
		
		#if( "`printf "\""${value}"\"" | sed -r "\""s/^(~)(.*)/\1/"\""`" == "~" ) then
		#	set value="`printf "\""${value}"\"" | sed -r "\""s/^(~)(.*)/${escaped_home_dir}\2/"\"" | sed -r 's/["\$"]/"\""\\"\$""\""/g' | sed -r 's/^\ //' | sed -r 's/(["\""])/"\""\\"\"""\""/g' | sed -r 's/([*])/\\\1/g' | sed -r 's/(['\!'])/\\\1/g' | sed -r 's/(\[)/\\\1/g'`";
		#endif
		
		#if( "`printf "\""${value}"\"" | sed -r "\""s/^(\.)(.*)/\1/"\""`" == "." ) then
		#	set value="`printf "\""${value}"\"" | sed -r "\""s/^(\.)(.*)/${escaped_starting_dir}\2/"\"" | sed -r 's/["\$"]/"\""\\"\$""\""/g' | sed -r 's/^\ //' | sed -r 's/(["\""])/"\""\\"\"""\""/g' | sed -r 's/([*])/\\\1/g' | sed -r 's/(['\!'])/\\\1/g' | sed -r 's/(\[)/\\\1/g'`";
		#endif
		
		#if( "`printf "\""${value}"\"" | sed -r "\""s/^(.*)(\*)"\$"/\2/"\""`" == "*" ) then
		#	set dir="`printf "\""${value}"\"" | sed -r "\""s/^(.*)\*"\$"/\2/"\""`";
		#	set value="`/bin/ls --width=1 "\""${dir}"\""*`";
		#endif
		
		@ parsed_argc++;
		set parsed_arg="${dashes}${option}${equals}${quotes}${value}${quotes}";
		if(! ${?parsed_argv} ) then
			set parsed_argv="${parsed_arg}";
		else
			set parsed_argv="${parsed_argv} ${parsed_arg}";
		endif
		
		if( ${?debug} || ${?diagnostic_mode} ) \
			printf "\tparsed option %sparsed_argv[%d]: %s\n" \$ "$parsed_argc" "${parsed_arg}";
		
		switch("${option}")
			case "diagnosis":
			case "diagnostic-mode":
			case "debug":
				if(${?arg_shifted}) then
					@ arg--;
					unset arg_shifted;
				endif
				set argv[$arg]="";
				breaksw;
			
			case "L":
			case "H":
			case "P":
				if(${?arg_shifted}) then
					@ arg--;
					unset arg_shifted;
				endif
				set follow_symlinks="${option}";
				set argv[$arg]="";
				breaksw;
			
			case "regextype":
				if(${?arg_shifted}) then
					@ arg--;
					unset arg_shifted;
				endif
				set argv[$arg]="";
				switch("${value}")
					case "emacs":
					case "posix-awk":
					case "posix-basic":
					case "posix-egrep":
					case "posix-extended":
						set regextype="${value}"
						breaksw;
					
					default:
						printf "Invalid %s specified.  Supported %s values are: posix-extended (this is the default), posix-awk, posix-basic, posix-egrep and emacs.\n" "${option}" "${option}" > /dev/stderr;
						breaksw;
				endsw
				breaksw;
			
			default:
				if( -d "$argv[$arg]" || -e "$argv[$arg]" ) then
					set find_target="$argv[$arg]";
					set argv[$arg]="";
					breaksw;
				endif
				
				if(! ${?argz} ) then
					printf "%s%s is an unsupported option.  See %s -h|--help for more information.\n" "${dashes}" "${option}" "${scripts_basename}" >& /dev/stderr;
					breaksw;
				endif
				
				if( "${argz}" == "" ) then
					set argz="${parsed_arg}";
				else
					set argz=("${argz}" "\n" "${parsed_arg}");
				endif
				breaksw;
		endsw
		
		if( ${?arg_shifted} ) then
			unset arg_shifted;
			@ arg--;
		endif
		
		unset dashes option equals value parsed_arg;
	end
	goto exec;
#parse_arg:

