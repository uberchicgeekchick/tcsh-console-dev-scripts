#!/bin/tcsh -f
setenv:
	onintr scripts_main_quit;
	
	set scripts_basename="oggconvert";
	set scripts_tmpdir="`mktemp --tmpdir -d tmpdir.for.${scripts_basename}.XXXXXXXXXX`";
	
	set scripts_supported_extensions_defaults="ogg|mp3|m4a|rm|wma|wav";
	set scripts_supported_extensions="${scripts_supported_extensions_defaults}";
	set escaped_home_dir="`printf "\""%s"\"" "\""${HOME}"\"" | sed -r 's/(["\$\"\!\`"])/"\""\\\1"\""/g' | sed -r 's/([\[\/])/\\\1/g'`";
	set escaped_starting_cwd="`printf "\""%s"\"" "\""${cwd}"\"" | sed -r 's/(["\$\"\!\`"])/"\""\\\1"\""/g' | sed -r 's/([\[\/])/\\\1/g'`";
	set supports_being_sourced;
	#set process_each_filename;
	
	goto debug_check;
#goto setenv;


exit_script:
	onintr -;
	goto scripts_main_quit;
#goto exit_script;

scripts_main_quit:
	onintr -;
	
	if( ${?playlist} ) then
		if(! ${?playlists_new_files} ) then
			if( -e "${playlist}.swp" ) \
				rm "${playlist}.swp";
			if( -e "${playlist}.new" ) \
				rm "${playlist}.new";
		else
			printf "\n\t";
			playlist:new:save.tcsh "${playlist}";
			printf "\n";
			unset playlists_new_files;
		endif
		unset playlist;
	endif
	
	if( ${?filename} ) \
		unset filename;
	if( ${?original_extension} ) \
		unset original_extension;
	
	if( ${?skip_message_shown} ) \
		unset skip_message_shown;
	
	if( ${?save_to_filename} ) \
		unset save_to_filename;
	
	if( ${?extension} ) \
		unset extension;
	
	if( ${?filename_list} ) then
		if( -e "${filename_list}") \
			rm -f "${filename_list}";
		if( -e "${filename_list}.all") \
			rm -f "${filename_list}.all";
		unset filename_list;
	endif
	if( ${?filename_list_value} ) \
		unset filename_list_value;
	
	if( ${?files_processed} ) \
		unset files_processed;
	if( ${?files_coverted} ) \
		unset files_coverted;
	if( ${?files_combined} ) \
		unset files_combined;
	
	if( ${?use_old_owd} ) then
		cd "${owd}";
		set owd="${use_old_owd}";
		unset use_old_owd;
	endif
	
	if( ${?scripts_tmpdir} ) then
		if( -d "${scripts_tmpdir}" ) \
			rm -rf "${scripts_tmpdir}";
		unset scripts_tmpdir;
	endif
	
	if( ${?add_length} ) \
		unset add_length;
	if( ${?all_filenames} ) \
		unset all_filenames;
	if( ${?argc} ) \
		unset argc;
	if( ${?combine} ) \
		unset combine;
	if( ${?confirmation} ) \
		unset confirmation;
	if( ${?debug_arguments} ) \
		unset debug_arguments;
	if( ${?debug_dependencies} ) \
		unset debug_dependencies;
	if( ${?debug_encoding} ) \
		unset debug_encoding;
	if( ${?debug_filelist} ) \
		unset debug_filelist;
	if( ${?debug_length} ) \
		unset debug_length;
	if( ${?debug_logging} ) \
		unset debug_logging;
	if( ${?diagnostic_mode} ) \
		unset diagnostic_mode;
	if( ${?original_filename} ) \
		unset original_filename;
	if( ${?escaped_home_dir} ) \
		unset escaped_home_dir;
	if( ${?escaped_starting_cwd} ) \
		unset escaped_starting_cwd;
	if( ${?file_count} ) \
		unset file_count;
	if( ${?function} ) \
		unset function;
	if( ${?itsoffset} ) \
		unset itsoffset;
	if( ${?modifier} ) \
		unset modifier;
	if( ${?oggenc} ) \
		unset oggenc;
	if( ${?oggenc_output_file_options} ) \
		unset oggenc_output_file_options;
	if( ${?output} ) \
		unset output;
	if( ${?parsed_arg} ) \
		unset parsed_arg;
	if( ${?parsed_argc} ) \
		unset parsed_argc;
	if( ${?parsed_argv} ) \
		unset parsed_argv;
	if( ${?playlists_new_files} ) \
		unset playlists_new_files;
	if( ${?reverse_modifier} ) \
		unset reverse_modifier;
	if( ${?scripts_basename} ) \
		unset scripts_basename;
	if( ${?scripts_path} ) \
		unset scripts_path;
	if( ${?supports_being_sourced} ) \
		unset supports_being_sourced;
	if( ${?usage_displayed} ) \
		unset usage_displayed;
	if( ${?nodeps} ) \
		unset nodeps;
	if(! ${?errno} ) \
		@ errno=0;
	
	@ status=$errno;
	exit ${status}
#goto scripts_main_quit;


debug_check:
	@ arg=0;
	@ argc=${#argv};
	while( $arg < $argc )
		@ arg++;
		if( -e "$argv[${arg}]" ) \
			continue;
		
		switch( "$argv[${arg}]" )
			case "h":
			case "help":
				goto usage;
				breaksw;
			
			case "--":
				if(! ${?process_each_filename} ) \
					set process_each_filename;
			continue;
			
			case "--!":
				if( ${?process_each_filename} ) \
					unset process_each_filename;
			continue;
		endsw
		
		set argument_file="${scripts_tmpdir}/.escaped.argument.${scripts_basename}.argv[${arg}].`date '+%s'`.arg";
		printf "%s" "$argv[${arg}]" >! "${argument_file}";
		ex -X -n --noplugin -s '+s/\v([\"\!\$\`])/\"\\\1\"/g' '+wq!' "${argument_file}";
		set argument="`cat "\""${argument_file}"\""`";
		rm -f "${argument_file}";
		unset argument_file;
		
		set option="`printf "\""%s"\"" "\""${argument}"\"" | sed -r 's/^([\-]{1,2})([^\=]+)(\=)?(.*)"\$"/\2/'`";
		set value="`printf "\""%s"\"" "\""${argument}"\"" | sed -r 's/^([\-]{1,2})([^\=]+)(\=)?(.*)"\$"/\4/'`";
		if( -e "${value}" ) \
			continue;
		
		if( ${?debug} || ${?debug_arguments} ) \
			printf "**%s [debug_check:]**"\$"option: [${option}]; "\$"value: [${value}].\n" "${scripts_basename}";
		
		switch("${option}")
			case "nodeps":
				if( ${?nodeps} ) \
					breaksw;
				
				set nodeps;
				breaksw;
			
			case "diagnosis":
			case "diagnostic-mode":
				if( ${?diagnostic_mode} ) \
					breaksw;
				
				printf "**%s debug:**, via "\$"argv[%d], diagnostic mode:\t[enabled].\n\n" "${scripts_basename}" ${arg};
				set diagnostic_mode;
				if(! ${?debug} ) \
					set debug;
				breaksw;
			
			case "debug":
				switch("${value}")
					case "length":
						if( ${?debug_length} ) \
							breaksw;
						
						printf "**%s notice:**, via "\$"argv[%d], length debugging:\t[enabled]\n\n" "${scripts_basename}" ${arg};
						set debug_length;
						breaksw;
					
					case "encoding":
						if( ${?debug_encoding} ) \
							breaksw;
						
						printf "**%s notice:**, via "\$"argv[${arg}], encoding debugging:\t[enabled]\n\n" "${scripts_basename}";
						set debug_encoding;
						breaksw;
					
					case "dependencies":
						if( ${?debug_dependencies} ) \
							breaksw;
						
						printf "**%s notice:**, via "\$"argv[${arg}], debugging dependencies:\t[enabled]\n\n" "${scripts_basename}";
						set debug_dependencies;
						breaksw;
					
					case "argv":
					case "parse_argv":
					case "arguments":
						if( ${?debug_arguments} ) \
							breaksw;
						
						printf "**%s**, via "\$"argv[${arg}], debugging arguments:\t[enabled].\n\n" "${scripts_basename}";
						set debug_arguments;
						breaksw;
					
					case "filelist":
						if( ${?debug_filelist} ) \
							breaksw;
						
						printf "**%s**, via "\$"argv[${arg}], filelist debugging:\t[enabled].\n\n" "${scripts_basename}";
						set debug_filelist;
						breaksw;
					
					case "logged":
						if( ${?logging} ) \
							breaksw;
						
						printf "**%s**, via "\$"argv[${arg}], debug logging:\t[enabled].\n\n" "${scripts_basename}";
						set debug_logging;
						breaksw;
					
					default:
						if( ${?debug} ) \
							breaksw;
						
						printf "**%s notice:**, via "\$"argv[${arg}], debug mode:\t[enabled]\n\n" "${scripts_basename}";
						set debug;
						breaksw;
				endsw
				breaksw;
			
			default:
				continue;
		endsw
	end
#goto debug_check;


check_dependencies:
	set dependencies=("${scripts_basename}" "ffmpeg" "oggenc" "ogginfo" "playlist:new:create.tcsh" "playlist:new:save.tcsh");# `printf ${scripts_basename} | sed -r 's/(.*)\.(tcsh|cshrc)$/\1/'`");
	@ dependencies_index=0;
	foreach dependency(${dependencies})
		@ dependencies_index++;
		
		if( ${?nodeps} && $dependencies_index > 1 ) \
			break;
		
		if( ${?debug} || ${?debug_dependencies} ) \
			printf "\n**%s debug:** looking for dependency: %s.\n\n" "${scripts_basename}" "${dependency}"; 
			
		foreach program("`where "\""${dependency}"\""`")
			if( -x "${program}" ) \
				break;
			unset program;
		end
		
		if(! ${?program} ) then
			@ errno=-501;
			printf "One or more required dependencies couldn't be found.\n\t[%s] couldn't be found.\n\t%s requires: %s\n" "${dependency}" "${scripts_basename}" "${dependencies}";
			goto scripts_main_quit;
		endif
		
		if( ${?debug} || ${?debug_dependencies} ) then
			switch( "`printf "\""%d"\"" "\""${dependencies_index}"\"" | sed -r 's/^[0-9]*[^1]?([0-9])"\$"/\1/'`" )
				case "1":
					set suffix="st";
					breaksw;
				
				case "2":
					set suffix="nd";
					breaksw;
				
				case "3":
					set suffix="rd";
					breaksw;
				
				default:
					set suffix="th";
					breaksw;
			endsw
			
			printf "**%s debug:** found %s%s dependency: %s.\n" "${scripts_basename}" "${dependencies_index}" "${suffix}" "${dependency}";
			unset suffix;
		endif
		
		switch("${dependency}")
			case "${scripts_basename}":
				if( ${?script} ) \
					breaksw;
				
				set old_owd="${cwd}";
				cd "`dirname "\""${program}"\""`";
				set scripts_path="${cwd}";
				cd "${owd}";
				set owd="${old_owd}";
				unset old_owd;
				set script="${scripts_path}/${scripts_basename}";
				breaksw;
			
			case "ffmpeg":
				set ffmpeg="${program}";
				breaksw;
			
			case "oggenc":
				set oggenc="${program}";
				breaksw;
			
			case "ogginfo":
				set ogginfo="${program}";
				breaksw;
			
		endsw
		
		unset program;
	end
	
	unset dependency dependencies dependencies_index;
	
	goto if_sourced;
#goto check_dependencies;


if_sourced:
	if( ${?0} ) \
		goto main;
	
	# START: special handler for when this file is sourced.
	if(! ${?TCSH_RC_SESSION_PATH} ) \
		setenv TCSH_RC_SESSION_PATH "${scripts_path}/../tcshrc";
	source "${TCSH_RC_SESSION_PATH}/argv:check" "${scripts_basename}" ${argv};
	
	if( ${?debug} ) \
		printf "Setting up aliases for: oggconvert, oggcombine, and oggtranscode.\n";
	
	alias oggconvert "${script}";
	alias oggtranscode "${script} --transcode";
	alias oggcombine "${script} --combine";
	
	source "${TCSH_RC_SESSION_PATH}/argv:clean-up" "${scripts_basename}";
	# FINISH: special handler for when this file is sourced.
	
	goto scripts_main_quit;
#goto if_sourced;


main:
	alias ex "ex -E -X -n --noplugin";
	
	if( ! ${?debug} && ! ${?debug_encoding} ) then
		set output="/dev/null";
	else
		set output="/dev/stdout";
	endif
	
	@ files_processed=0;
	@ files_coverted=0;
	
	@ volume=1024
	
	goto parse_argv;
#goto main;


cancel_convert:
	onintr scripts_main_quit;
	
	if( ${?length} && ! ${?length_set} ) \
		unset length;
	
	if(!( ${?save_to_filename} && ${?original_extension} )) then
		sleep 2;
		goto convert_filename_list;
	endif
	
	onintr -;
	printf "\t[cancelled]\n";
	
	if( "${original_extension}" != "wav" && -e "${save_to_filename}.wav" ) \
		rm "${save_to_filename}.wav";
	
	if( "${original_extension}" != "ogg" && -e "${save_to_filename}.ogg" ) \
		rm "${save_to_filename}.ogg";
	
	if( -e "${save_to_filename}.${original_extension}.bck" ) then
		if( "${original_extension}" == "ogg" || "${original_extension}" == "wav" ) then
			mv -f "${save_to_filename}.${original_extension}.bck" "${save_to_filename}.${original_extension}";
		else
			rm -f "${save_to_filename}.${original_extension}.bck";
		endif
	endif
	
	unset save_to_filename original_extension;
	onintr scripts_main_quit;
	sleep 2;
	goto convert_filenames;
#goto cancel_convert;


convert_filename_list:
	onintr cancel_convert;
	
	if(! ${?filename_list} ) \
		goto usage;
	
	if( ${?length} && ! ${?length_set} ) \
		unset length;
	
	set filename_list_value="`head -1 "\""${filename_list}"\""`";
	ex -s '+1d' '+wq!' "${filename_list}";
	
	if( ${?length_set} && ${?rtrim} ) then
		printf "\t**Error:** both --length and --rtrim cannot be specified at the same time.\n\n" > /dev/stderr;
		@ errno=-610;
		if(! ${?process_each_filename} ) then
			goto scripts_main_quit;
		else
			goto parse_arg;
		endif
	endif
	
	cat "${filename_list}" | sort | uniq > "${filename_list}.swp";
	mv -f "${filename_list}.swp" "${filename_list}";
	
	set file_count="`wc -l "\""${filename_list}"\"" | sed -r 's/^([0-9]+)(.*)"\$"/\1/'`";
	if(!( ${file_count} > 0 )) then
		@ errno=0;
		printf "\t**Skipping:** <file://%s> no convertable files were found.\n\n" "${filename_list_value}" > /dev/stderr;
		if(! ${?process_each_filename} ) then
			goto scripts_main_quit;
		else
			goto parse_arg;
		endif
	endif
	
	if(! -e "${filename_list}.all" ) then
		cp "${filename_list}" "${filename_list}.all";
	else
		foreach filename_prev( "`cat "\""${filename_list}.all"\""`")# | sed -r 's/(["\"\$\!\`"])/"\""\\\1"\""/g'`")# | sed -r 's/(["\""])/"\""\\"\"""\""/g'`")
			@ line=0;
			foreach filename_next( "`cat "\""${filename_list}"\""`")# | sed -r 's/(["\"\$\!\`"])/"\""\\\1"\""/g'`")# | sed -r 's/(["\"\$\!\`"])/"\""\\"\\1""\""/g'`" )
				@ line++;
				if( "${filename_prev}" == "${filename_next}" ) then
					#printf "\t**Skipping:** <file://%s> its already been converted.\n\n" "${filename_next}";
					ex -s "+${line}d" '+wq!' "${filename_list}";
					@ line--;
				endif
				unset filename_next;
			end
			unset line filename_prev;
		end
		set file_count="`wc -l "\""${filename_list}"\"" | sed -r 's/^([0-9]+)(.*)"\$"/\1/'`";
		if(!( ${file_count} > 0 )) then	
			@ errno=0;
			printf "\t**Skipping:** <file://%s> all convertable files have been processed.\n\n" "${filename_list_value}" > /dev/stderr;
			if(! ${?process_each_filename} ) then
				goto scripts_main_quit;
			else
				goto parse_arg;
			endif
		endif
		cat "${filename_list}" >> "${filename_list}.all";
		set file_count="`wc -l "\""${filename_list}.all"\"" | sed -r 's/^([0-9]+)(.*)"\$"/\1/'`";
	endif
	
	if( ${?debug} || ${?debug_filelist} ) \
		cat "${filename_list}";
	
	if( ${?length_set} && ${?ltrim} ) then
		goto find_length;
	endif
	
	goto convert_filenames;
#goto convert_filename_list;

	
convert_filenames:
	onintr cancel_convert;
	
	if( ${?length} && ! ${?length_set} ) \
		unset length;
	
	foreach original_filename( "`cat "\""${filename_list}"\"" | sed -r 's/(["\"\$\!\`"])/"\""\\\1"\""/g'`" )
		if( ${?debug} || ${?debug_filelist} ) \
			printf "\tParsing: %s.\n" "${original_filename}";
		ex -s '+1d' '+wq!' "${filename_list}";
		@ files_processed++;
		set extension="`printf "\""%s"\"" "\""${original_filename}"\"" | sed -r 's/^(.*)\.([^.]+)"\$"/\2/g'`";
		set original_extension="${extension}";
		set filename="`printf "\""%s"\"" "\""${original_filename}"\"" | sed -r 's/^(.*)\.([^.]+)"\$"/\1/g'`";
		set save_to_filename="${filename}";
		if( ${?debug} || ${?debug_filelist} ) \
			printf "\tLooking for: %s.%s\n" "${filename}" "${extension}";
		
		if(! -e "${filename}.${extension}" ) then
			printf "\t**%s error:** <file://%s.%s> no longer exists\t[skipping]\n\n" "${scripts_basename}" "${filename}" "${extension}" > /dev/stderr;
			continue;
		endif
		
		if( -e "${save_to_filename}.ogg" ) then
			if( "${extension}" == "ogg" && ! ${?re_encode} ) then
				printf "\t**Skipping:** <file://%s.%s> " "${filename}" "${extension}";
				if( "${extension}" != "ogg" ) \
					printf ", <file://%s.ogg> already exists, " "${filename}";
				printf "re-encoding is disabled.\n\n";
				continue;
			endif
			
			if( "${extension}" == "ogg" && (!( ${?re_encode} || ${?ltrim} || ${?rtrim} || ${?length} )) ) then
				printf "\t**Skipping:** <file://%s.%s> " "${filename}" "${extension}";
				if( "${extension}" != "ogg" ) \
					printf ", <file://%s.ogg> already exists, " "${filename}";
				if(! ${?re_encode} ) \
					printf "re-encoding has not been enabled"
				if( ! ${?re_encode} && (!( ${?ltrim} || ${?rtrim} || ${?length} )) ) \
					printf "and ";
				if(!( ${?ltrim} || ${?rtrim} || ${?length} )) \
					printf "no advanced conversion options were specified";
				printf ".\n\n";
				continue;
			endif
			
			if(! ${?force} ) \
				goto confirm_overwrite;
		endif
		
		if( "${extension}" != "ogg" ) \
			goto oggconvert;
		
		if(! ${?force} ) \
			goto confirm_overwrite;
		
		if( ${?rtrim} && ! ${?ltrim} ) \
			goto find_length;
		
		goto oggconvert;
		
		printf "\t**Skipping:** <file://%s.%s>; no advanced conversion options specified.\n\n" "${filename}" "${extension}";
		continue;
	end
	
	rm -f "${filename_list}";
	
	if( ${?arg} ) then
		goto parse_arg;
	endif
	
	onintr scripts_main_quit;
	
	if( ${?combine} ) then
		if( ${file_count} <= 1 ) then
			printf "--combine reqires at least two input files.\n";
			@ errno=-5;
			goto scripts_main_quit;
		else
			goto init_combine;
		endif
	endif
	
	if( ${?filename} ) \
		unset filename;
	
	if( ${?save_to_filename} ) \
		unset save_to_filename;
	
	if( ${?extension} ) \
		unset extension;
	
	if( ${?original_extension} ) \
		unset original_extension;
	
	goto scripts_main_quit;
#goto convert_filenames;


confirm_overwrite:
	if(! -e "${filename}.ogg" ) \
		goto oggconvert;
	
	printf "\n\t**Warning:** <file://%s.ogg> already exists.\n\t\tWould you like to re-convert it? [Yes/Always/Skip all/No(default)]" "${filename}";
	set confirmation="$<";
	printf "\n";
	
	switch(`printf "%s" "${confirmation}" | sed -r 's/^(.).*$/\l\1/'`)
		case "a":
			printf "\tTip: you can run "\`"%s --re-encode=force"\`" to skip this prompt in the future.\n\n" "${filename}" "${scripts_basename}" "${scripts_basename}";
			if(! ${?force} ) \
				set force;
			if(! ${?re_encode} ) \
				set re_encode;
		case "y":
			if( ${?ltrim} || ${?length} || "${original_extension}" != "ogg" ) \
				goto oggconvert;
			
			if( ${?rtrim} ) \
				goto find_length;
			
			goto oggconvert;
			breaksw;
		
		case "s":
			printf "\t**Skipping:** <file://%s.ogg>,\n\t\tTip: you can run "\`"%s --no-re-encode to skip all existing files w/o prompting"\`".\n\n" "${filename}" "${scripts_basename}";
			set skip_message_shown;
			if( ${?force} ) \
				unset force;
			if( ${?re_encode} ) \
				unset re_encode;
		case "n":
		default:
			if(! ${?skip_message_shown} ) then
				printf "\t**Skipping:** <file://%s.ogg>." "${filename}";
			else
				unset skip_message_shown;
			endif
			@ errno=-4;
			goto convert_filenames;
			breaksw;
	endsw
#goto confirm_overwrite;


oggconvert:
	printf "\n\tConverting";
	if( ${file_count} > 1 ) \
		printf " (file %s of %s)" "${files_processed}" "${file_count}";
	printf ":\n\t\t<%s.%s>\n" "${save_to_filename}" "${original_extension}";
	
	if(! -e "${save_to_filename}.${original_extension}.bck" ) \
		cp -f "${save_to_filename}.${original_extension}" "${save_to_filename}.${original_extension}.bck";
	
	if( "${extension}" != "wav" || ${?ltrim} || ${?rtrim} || ${?length} || ${?volume} ) then
		set ffmpeg_input_file_options="";
		set ffmpeg_output_file_options="";
		
		if( ${?length} && ( ${?rtrim} || ! ${?ltrim} ) ) then
			if( ${?rtrim} ) then
				printf "\t\tRemoving: [%s] from its ending.\n" "${rtrim}";
			else
				printf "\t\tLimiting: [%s] as its maximum length.\n" "${length}";
			endif
			set ffmpeg_input_file_options=" -t ${length}";
			if( ${?volume} && ! ${?ltrim} ) then
				printf "\t\tAnd setting its default volume to: [%s].\n" "${volume}";
				set ffmpeg_output_file_options=" -vol ${volume}";
			endif
		else if( ${?ltrim} && ${?length} ) then
			printf "\t\tTrimming: [%s] from its begining, and limiting its maximum length to: [%s].\n" "${ltrim}" "${length}";
			set ffmpeg_input_file_options=" -t ${length} -ss ${ltrim}";
			if( ${?volume} ) then
				printf "\t\tAnd setting its default volume to: [%s]\n" "${volume}";
				set ffmpeg_output_file_options=" -vol ${volume}";
			endif
		else if( ${?ltrim} ) then
			printf "\t\tTrimming: [%s] from its begining.\n" "${ltrim}";
			set ffmpeg_input_file_options=" -ss ${ltrim}";
			if( ${?volume} ) then
				printf "\t\tAnd setting its default volume to: [%s].\n" "${volume}";
				set ffmpeg_output_file_options=" -vol ${volume}";
			endif
		else if( ${?volume} ) then
			printf "\t\tSetting its default volume to: [%s].\n" "${volume}";
			set ffmpeg_output_file_options=" -vol ${volume}";
		endif
		
		if( "${extension}" == "" && ${?combine} ) then
			set ffmpeg_output_file_options=" -ac 1";#" -ar 44100 -ab 64000";
		else if( "${extension}" == "ogg" ) then
			set ffmpeg_input_file_options="${ffmpeg_input_file_options} -acodec vorbis";
		else# if( "${extension}" != "" ) then
			set ffmpeg_output_file_options=" -ac 1";#" -ab 64000";
		endif
		
		if( "${original_extension}" != "wav" || "${ffmpeg_input_file_options}" != "" ) then
			printf "\t\t\tCreating temporary WAV file.  This may take several moments...";
			
			if( ${?debug} || ${?debug_encoding} ) then
				printf "\n\nRunning:\n\t";
				printf "( %s -y%s -i "\""%s.%s"\""%s "\""%s.wav"\"" > %s ) >& /dev/stderr;" "${ffmpeg}" "${ffmpeg_input_file_options}" "${filename}" "${extension}" "${ffmpeg_output_file_options}" "${save_to_filename}" "${output}";
				printf "\n\n";
			endif
			
			if( ${?combine} && "${filename}" != "${save_to_filename}" ) then
				printf "#\!/bin/tcsh -f\nset echo;\n%s -y%s -i "\""%s.%s"\""%s "\""%s.wav"\"";\n" "${ffmpeg}" "${ffmpeg_input_file_options}" "${filename}" "${extension}" "${ffmpeg_output_file_options}" "${save_to_filename}" >! "./ffmpeg-combined.tcsh";
				chmod u+x "./ffmpeg-combined.tcsh";
				"./ffmpeg-combined.tcsh";
				#rm "./ffmpeg-combined.tcsh";
				#${ffmpeg} -y${ffmpeg_input_file_options} ${filename}.${extension}${ffmpeg_output_file_options} "${save_to_filename}.wav" >& ${output};
			else
				${ffmpeg} -y${ffmpeg_input_file_options} -i "${filename}.${extension}"${ffmpeg_output_file_options} "${save_to_filename}.wav" >& ${output};
			endif
			
			unset ffmpeg_input_file_options ffmpeg_output_file_options;
			
			if(!( "${status}" == "0" && -e "${save_to_filename}.wav" )) then
				printf "\t[failed]\n\t\t\tUnable to create temorary WAV file.\n\t\t\tffmpeg returned: %s\n\n" "${status}";
				if( "${original_extension}" != "wav" && -e "${save_to_filename}.wav" ) \
					rm "${save_to_filename}.wav";
				
				if( -e "${save_to_filename}.${original_extension}.bck" ) then
					if( "${original_extension}" == "wav" ) then
						mv -f "${save_to_filename}.${original_extension}.bck" "${save_to_filename}.${original_extension}";
					else
						rm -f "${save_to_filename}.${original_extension}.bck";
					endif
				endif
				
				goto convert_filenames;
			endif
			printf "\t\t[success]\n";
		endif
	endif
	
	if( "${extension}" == "" && ${?combine} ) then
		set oggenc_output_file_options=" -q 10";
	else if( "${extension}" == "ogg" ) then
		set oggenc_output_file_options="";#" -q 5";
	else if( "${extension}" != "" ) then
		set oggenc_output_file_options="";#" -q 5";
	endif
		
	printf "\t\t\tEncoding OGG Vorbis file.  Please wait several moments...";
	
	${oggenc} ${oggenc_output_file_options} "${save_to_filename}.wav" >& ${output};
	if(!( "${status}" == "0" && -e "${save_to_filename}.ogg" )) then
		printf "\t[failed]\n\t\t\tUnable to encode file.  Encoder: [`basename %s`]; returned: %s\n\n" "${oggenc}" "${status}";
		if( "${original_extension}" != "wav" && -e "${save_to_filename}.wav" ) then
			rm "${save_to_filename}.wav";
		else if( "${original_extension}" != "ogg" && -e "${save_to_filename}.ogg" ) then
			rm "${save_to_filename}.ogg";
		endif
		
		if( -e "${save_to_filename}.${original_extension}.bck" ) then
			if( "${original_extension}" == "ogg" ) then
				mv -f "${save_to_filename}.${original_extension}.bck" "${save_to_filename}.${original_extension}";
			else
				rm -f "${save_to_filename}.${original_extension}.bck";
			endif
		endif
		
		goto convert_filenames;
	endif
	
	printf "\t\t[success]\n";
	if( "${original_extension}" != "wav" ) \
		rm -f "${save_to_filename}.wav";
	
	if( -e "${save_to_filename}.${original_extension}.bck" ) \
		rm -f "${save_to_filename}.${original_extension}.bck";
	
	if( ${?combine} && "${filename}" != "${save_to_filename}" ) \
		goto scripts_main_quit;
	
	if( ${?rtrim} && ! ${?length} ) \
		goto find_length;
	
	if( ${?debug} || ${?debug_length} || ${?debug_encoding} ) then
		${ogginfo} "${save_to_filename}.ogg";
	endif
	
	if( ${?playlist} ) then
		if(! ${?playlists_new_files} ) then
			@ playlists_new_files=1;
		else
			@ playlists_new_files++;
		endif
		
		if( "`printf "\""%s"\"" "\""${save_to_filename}"\"" | sed -r 's/^(.)(.*)"\$"/\1/'`" != "/" ) \
			printf "%s/" "${cwd}" >> "${playlist}.new";
		printf "%s.ogg\n" "${save_to_filename}" >> "${playlist}.new";
	endif
	
	printf "\t\t\t\t\t\t\t\tOGG Vorbis conversion:\t\t[completed]\n\n";
	
	if( ${?transcode} && "${original_extension}" != "ogg" ) then
		rm ${transcode} "${filename}.${original_extension}";
	endif
	
	@ files_coverted++;
	goto convert_filenames;
#goto oggconvert;


find_length:
	if( ! ${?debug} && ( ${?debug_length} || ${?debug_encoding} ) ) then
		set debug;
		set debug_set;
	endif
	
	if(! ${?add_length} ) then
		set function="minus";
		set modifier="-";
		set reverse_modifier="+";
	else
		set function="add";
		set modifier="+";
		set reverse_modifier="-";
	endif
	
	if( ${?length_set} && ${?ltrim} ) then
		set rtrim_set;
		set rtrim="${ltrim}";
		set oggs_hours="`printf "\""%s"\"" "\""${length_set}"\"" | sed -r 's/([0-9]{2}):([0-9]{2}):([0-9]{2})/\1/'`";
		set oggs_minutes="`printf "\""%s"\"" "\""${length_set}"\"" | sed -r 's/([0-9]{2}):([0-9]{2}):([0-9]{2})/\2/'`";
		set oggs_seconds="`printf "\""%s"\"" "\""${length_set}"\"" | sed -r 's/([0-9]{2}):([0-9]{2}):([0-9]{2})/\3/'`";
	else
		set original_filename="`printf "\""%s"\"" "\""${original_filename}"\"" | sed -r 's/^(.*)\.([^.]+)"\$"/\1/' | sed -r 's/(["\"\$\!\`"])/"\""\\\1"\""/g'`.ogg";
		set oggs_length="`${ogginfo} "\""${original_filename}"\"" | /bin/grep --perl-regexp 'Playback length:'`";
		if( ${?debug} ) \
			printf "Length of %s\n\t%s\n" "${original_filename}" "${oggs_length}";
		set oggs_minutes="`printf "\""%s"\"" "\""${oggs_length}"\"" | sed -r 's/^[^0-9]*([0-9]*)(m:)([0-9]+)\..*"\$"/\1/'`";
		if( "${oggs_minutes}" == "${oggs_length}" ) then
			set oggs_hours="00";
			set oggs_minutes="00";
		else
			set oggs_hours="`printf "\""%s/60\n"\"" "\""${oggs_minutes}"\"" | bc`";
			set oggs_minutes="`printf "\""%s%%60\n"\"" "\""${oggs_minutes}"\"" | bc`";
		endif
		set oggs_seconds="`printf "\""%s"\"" "\""${oggs_length}"\"" | sed -r 's/^[^0-9]*([0-9]*)(m:)([0-9]+)\..*"\$"/\3/'`";
		if( "${oggs_seconds}" == "${oggs_length}" ) \
			set oggs_seconds="00";
		unset oggs_length;
	endif
	
	set trim_hours="`printf "\""%s"\"" "\""${rtrim}"\"" | sed -r 's/([0-9]{2}):([0-9]{2}):([0-9]{2})/\1/'`";
	set trim_minutes="`printf "\""%s"\"" "\""${rtrim}"\"" | sed -r 's/([0-9]{2}):([0-9]{2}):([0-9]{2})/\2/'`";
	set trim_seconds="`printf "\""%s"\"" "\""${rtrim}"\"" | sed -r 's/([0-9]{2}):([0-9]{2}):([0-9]{2})/\3/'`";
	
	if( ${?debug} ) then
		printf "\t%s%s%s\n" "${oggs_hours}" "${modifier}" "${trim_hours}";
		printf "\t%s%s%s\n" "${oggs_minutes}" "${modifier}" "${trim_minutes}";
		printf "\t%s%s%s\n" "${oggs_seconds}" "${modifier}" "${trim_seconds}";
	endif
	
	set hours="`printf "\""%s%s%s\n"\"" "\""${oggs_hours}"\"" "\""${modifier}"\"" "\""${trim_hours}"\"" | bc`";
	set minutes="`printf "\""%s%s%s\n"\"" "\""${oggs_minutes}"\"" "\""${modifier}"\"" "\""${trim_minutes}"\"" | bc`";
	set seconds="`printf "\""%s%s%s\n"\"" "\""${oggs_seconds}"\"" "\""${modifier}"\"" "\""${trim_seconds}"\"" | bc`";
	if( ${?debug} ) then
		printf "After %s rtrim length from the ogg file's length:\n" "${function}ing";
		printf "\thours: %s\n" "${hours}";
		printf "\tminutes: %s\n" "${minutes}";
		printf "\tseconds: %s\n" "${seconds}";
	endif
	
	if( ${?rtrim_set} && ${?ltrim} && ${?ltrim} ) \
		unset rtrim rtrim_set;
#goto find_length;


calculate_length:
	if( "${hours}" == "" ) then
		set hours="00";
	endif
	if( "`printf "\""%s"\"" "\""${minutes}"\"" | sed -r 's/^(\-).*/\1/'`" == "-" ) then
		set hours="`printf "\""%s%s1\n"\"" "\""${hours}"\"" "\""${modifier}"\"" | bc`";
		set minutes="`printf "\""(%s%s60)%s%s\n"\"" "\""${oggs_minutes}"\"" "\""${reverse_modifier}"\"" "\""${modifier}"\"" "\""${trim_minutes}"\"" | bc`";
	endif
	if( ${minutes} > 60 ) then
		set hours="`printf "\""%s+1\n"\"" "\""${hours}"\"" | bc`";
		set minutes="`printf "\""%s-60\n"\"" "\""${minutes}"\"" | bc`";
	endif
	if( "${minutes}" == "" ) then
		set minutes="00";
	endif
	
	if( "`printf "\""%s"\"" "\""${seconds}"\"" | sed -r 's/^(\-).*/\1/'`" == "-" ) then
		set minutes="`printf "\""%s%s1\n"\"" "\""${minutes}"\"" "\""${modifier}"\"" | bc`";
		set seconds="`printf "\""(%s%s60)%s%s\n"\"" "\""${oggs_seconds}"\"" "\""${reverse_modifier}"\"" "\""${modifier}"\"" "\""${trim_seconds}"\"" | bc`";
	endif
	if( ${seconds} > 60 ) then
		set minutes="`printf "\""%s+1\n"\"" "\""${minutes}"\"" | bc`";
		set seconds="`printf "\""%s-60\n"\"" "\""${seconds}"\"" | bc`";
	endif
	if( "${seconds}" == "" ) then
		set seconds="00";
	endif
	if( ${?debug} ) then
		printf "After calculating correct length:\n";
		printf "\thours: %s\n" "${hours}";
		printf "\tminutes: %s\n" "${minutes}";
		printf "\tseconds: %s\n" "${seconds}";
	endif
	
	if( "${hours}" == "" || "`printf "\""%s"\"" "\""${hours}"\"" | sed -r 's/^(\-).*/\1/'`" == "-" ) then
		set hours="00";
	endif
	if( "`printf "\""%s"\"" "\""${hours}"\"" | sed -r 's/^([0-9]{1})[0-9]{0,1}/\1/'`" == "${hours}" ) then
		set hours="0${hours}";
	endif
	if( "`printf "\""%s"\"" "\""${minutes}"\"" | sed -r 's/^([0-9]{1})[0-9]{0,1}/\1/'`" == "${minutes}" ) then
		set minutes="0${minutes}";
	endif
	if( "`printf "\""%s"\"" "\""${seconds}"\"" | sed -r 's/^([0-9]{1})[0-9]{0,1}/\1/'`" == "${seconds}" ) then
		set seconds="0${seconds}";
	endif
	if( ${?debug} ) then
		printf "After checkingfor any needed '0' padding:\n";
		printf "\thours: %s\n" "${hours}";
		printf "\tminutes: %s\n" "${minutes}";
		printf "\tseconds: %s\n" "${seconds}";
	endif
	
	set length="${hours}:${minutes}:${seconds}";
	if( "`printf "\""%s"\"" "\""${length}"\"" | sed -r 's/^[0-9]{2}:[0-9]{2}:[0-9]{2}"\$"//'`" != "" ) then
		printf "Invalid calculated length: %s, lenth must be formatted as: hh:mm:ss\n" "${length}";
		goto convert_filenames;
	endif
	if( ${?debug} ) then
		printf "Calcucated Length: %s\n" "${length}";
		if( "${extension}" == "ogg" ) \
			goto scripts_main_quit;
	endif
	
	unset oggs_hours trim_hours oggs_minutes trim_minutes oggs_seconds trim_seconds hours minutes seconds;
	
	if( ${?length_set} && ${?ltrim} ) \
		goto convert_filenames;
	
	if( "${extension}" != "ogg" ) \
		set extension="ogg";
	
	if( ${?debug_set} ) \
		unset debug_set debug;
	
	if( "${filename}" == "${save_to_filename}" ) \
		goto oggconvert;
	
	goto continue_combine;
#goto calculate_length;


init_combine:
	if(! ${?combine} ) \
		goto scripts_main_quit;
	
	if( ${?length} ) \
		unset length;
	if( ${?length_set} ) \
		unset length_set;
	
	@ files_combined=1;
	set extension="";
	set output="/dev/stdout";
	
	set old_owd="${owd}";
	cd "`dirname "\""${filename}"\""`";
	set save_to_filename="${cwd}/`basename "\""${cwd}"\""` - Combined";
	cd "${owd}";
	set owd="${old_owd}";
	unset old_owd;
	
	set add_length;
#goto init_combine;


continue_combine:
	if( ${?length} ) then
		set itsoffset="${length}";
		unset length;
	endif
	foreach filename ( "`cat "\""${filename_list}.all"\""`" )
		set filename="`printf "\""%s"\"" "\""${filename}"\"" | sed -r 's/^(.*)\.([^.]+)"\$"/\1/g'`";
		ex -s '+1d' '+wq' "${filename_list}.all";
		if(! -e "${filename}.ogg" ) \
			continue;
		
		@ files_combined++;
		if(! ${?all_filenames} ) then
			set all_filenames="-acodec vorbis -i "\""${filename}.ogg"\""";
			if( ${?rtrim} ) \
				unset rtrim;
			set rtrim="00:00:00";
			goto find_length;
		else
			set all_filenames="${all_filenames} -acodec vorbis -itsoffset ${itsoffset} -i "\""${filename}.ogg"\""";
			set rtrim="${itsoffset}";
			goto find_length;
		endif
	end
	set filename="${all_filenames}";
	set extension="";
	goto oggconvert;
#goto continue_combine;


usage:
	if(! ${?usage_displayed} ) then
		printf "Usage: %s [-h|help] [--|--"\!"] [--transcode] [--re-encode...] [--ltrim] [--rtrim] [--length] directory|directories|file(s)... [options]...\
	\
	%s converts any multimedia file into an OGG Vorbis audio file.\
	\
	Possible options are:\
		[-h|--help]	Displays this screen.\
		" "${scripts_basename}" "${scripts_basename}";
		set usage_displayed;
	endif
	
	if(! ${?no_exit_on_usage} ) then
		if(! ${?errno} ) \
			@ errno=0;
		goto scripts_main_quit;
	endif
	
	goto convert_filenames;
#goto usage;


parse_argv:
	onintr parse_argv_quit;
	
	if( ${#argv} == 0 ) \
		goto if_sourced;
	@ argc=${#argv};
	@ arg=0;
	
	if( ${?debug} ) \
		printf "Checking %s's argv options.  %s total.\n" "${scripts_basename}" "${argc}";
#goto parse_argv;


parse_arg:
	onintr cancel_convert;
	
	if( ${?playlist} ) then
		if(! ${?playlists_new_files} ) then
			if( -e "${playlist}.swp" ) \
				rm "${playlist}.swp";
			if( -e "${playlist}.new" ) \
				rm "${playlist}.new";
		else
			printf "\n\t";
			playlist:new:save.tcsh "${playlist}";
			printf "\n";
			unset playlists_new_files;
		endif
		unset playlist;
	endif
	
	while( $arg < $argc )
		if(! ${?arg_shifted} ) then
			@ arg++;
		else
			if( ${?value_used} ) \
				@ arg++;
			unset arg_shifted;
		endif
		
		if( ${?value_used} ) \
			unset value_used;
		
		if( ${?debug} || ${?debug_arguments} ) \
			printf "**%s debug:** Checking argv #%d (%s).\n" "${scripts_basename}" ${arg} "$argv[${arg}]";
		
		switch( "$argv[${arg}]" )
			case "--":
				if(! ${?process_each_filename} ) \
					set process_each_filename;
			continue;
			
			case "--!":
				if( ${?process_each_filename} ) \
					unset process_each_filename;
			continue;
		endsw
		
		set argument_file="${scripts_tmpdir}/.escaped.argument.${scripts_basename}.argv[${arg}].`date '+%s'`.arg";
		printf "%s" "$argv[${arg}]" >! "${argument_file}";
		ex -X -n --noplugin -s '+s/\v([\"\!\$\`])/\"\\\1\"/g' '+wq!' "${argument_file}";
		set argument="`cat "\""${argument_file}"\""`";
		rm -f "${argument_file}";
		unset argument_file;
		
		set dashes="`printf "\""%s"\"" "\""${argument}"\"" | sed -r 's/^([\-]{1,2})([^\=]+)(\=)?(.*)"\$"/\1/'`";
		if( "${dashes}" == "${argument}" ) \
			set dashes="";
		
		set option="`printf "\""%s"\"" "\""${argument}"\"" | sed -r 's/^([\-]{1,2})([^\=]+)(\=)?(.*)"\$"/\2/'`";
		if( "${option}" == "${argument}" ) \
			set option="";
		
		set equals="`printf "\""%s"\"" "\""${argument}"\"" | sed -r 's/^([\-]{1,2})([^\=]+)(\=)?(.*)"\$"/\3/'`";
		if( "${equals}" == "${argument}" ) \
			set equals="";
		
		set value="`printf "\""%s"\"" "\""${argument}"\"" | sed -r 's/^([\-]{1,2})([^\=]+)(\=)?(.*)"\$"/\4/'`";
		
		
		if( ${?debug} || ${?debug_arguments} ) \
			printf "\tparsed "\$"argument: [%s]; "\$"argv[%d] (%s)\n\t"\$"dashes: [%s];\n\t"\$"option: [%s];\n\t"\$"equals: [%s];\n\t"\$"value: [%s]\n\n" "${argument}" "${arg}" "$argv[${arg}]" "${dashes}" "${option}" "${equals}" "${value}";
		
		if( "${dashes}" != "" && "${option}" != "" && "${equals}" == "" && "${value}" == "" ) then
			@ arg++;
			if( ${arg} > ${argc} ) then
				@ arg--;
			else
				if( ${?debug} || ${?debug_arguments} ) \
					printf "**%s debug:** Looking for replacement value.  Checking argv #%d (%s).\n" "${scripts_basename}" ${arg} "$argv[${arg}]";
				
				set argument_file="${scripts_tmpdir}/.escaped.argument.${scripts_basename}.argv[${arg}].`date '+%s'`.arg";
				printf "%s" "$argv[${arg}]" >! "${argument_file}";
				ex -X -n --noplugin -s '+s/\v([\"\!\$\`])/\"\\\1\"/g' '+wq!' "${argument_file}";
				set test_argument="`cat "\""${argument_file}"\""`";
				rm -f "${argument_file}";
				unset argument_file;
				
				set test_dashes="`printf "\""%s"\"" "\""${test_argument}"\"" | sed -r 's/^([\-]{1,2})([^\=]+)(\=)?(.*)"\$"/\1/'`";
				if( "${test_dashes}" == "${test_argument}" ) \
					set test_dashes="";
				
				set test_option="`printf "\""%s"\"" "\""${test_argument}"\"" | sed -r 's/^([\-]{1,2})([^\=]+)(\=)?(.*)"\$"/\2/'`";
				if( "${test_option}" == "${test_argument}" ) \
					set test_option="";
				
				set test_equals="`printf "\""%s"\"" "\""${test_argument}"\"" | sed -r 's/^([\-]{1,2})([^\=]+)(\=)?(.*)"\$"/\3/'`";
				if( "${test_equals}" == "${test_argument}" ) \
					set test_equals="";
				
				set test_value="`printf "\""%s"\"" "\""${test_argument}"\"" | sed -r 's/^([\-]{1,2})([^\=]+)(\=)?(.*)"\$"/\4/'`";
				
				if(!( "${test_dashes}" == "" && "${test_option}" == "" && "${test_equals}" == "" && "${test_value}" == "${test_argument}" )) then
					@ arg--;
				else
					if( ${?debug} || ${?debug_arguments} ) \
						printf "\tparsed "\$"test_argument: [%s]; "\$"argv[%d] (%s)\n\t"\$"dashes: [%s];\n\t"\$"option: [%s];\n\t"\$"equals: [%s];\n\t"\$"value: [%s]\n\n" "${test_argument}" "${arg}" "$argv[${arg}]" "${test_dashes}" "${test_option}" "${test_equals}" "${test_value}";
					set equals=" ";
					set value="${test_value}";
					set arg_shifted;
				endif
				unset test_argument test_dashes test_option test_equals test_value;
			endif
		endif
		
		@ parsed_argc++;
		if( "${option}" == "${value}" ) \
			set option="";
		set parsed_arg="${dashes}${option}${equals}${value}";
		if(! ${?parsed_argv} ) then
			set parsed_argv="${parsed_arg}";
		else
			set parsed_argv="${parsed_argv} ${parsed_arg}";
		endif
		
		if( ${?debug} || ${?debug_arguments} ) \
			printf "\tparsed option "\$"parsed_argv[%d]: %s\n\n" ${parsed_argc} "${parsed_arg}";
		
		switch("${option}")
			case "nodeps":
			case "debug":
			case "diagnosis":
			case "diagnostic-mode":
				breaksw;
			
			case "any-file":
			case "all-files":
				if(! ${?scripts_supported_extensions} ) \
					breaksw;
				
				set scripts_supported_extensions_defaults="${scripts_supported_extensions}";
				unset scripts_supported_extensions;
				breaksw;
			
			case "default-files":
				if( ${?scripts_supported_extensions} && ${?scripts_supported_extensions_defaults} ) then
					if( "${scripts_supported_extensions}" == "${scripts_supported_extensions_defaults}" ) \
						breaksw;
				endif
				
				set scripts_supported_extensions="${scripts_supported_extensions_defaults}";
				breaksw;
			
			case "extension":
			case "extensions":
				if( ${?scripts_supported_extensions} ) \
					set scripts_supported_extensions_defaults="${scripts_supported_extensions}";
				
				set scripts_supported_extensions="${value}";
				breaksw;
			
			case "with-extension":
			case "with-extensions":
			case "include-extension":
			case "include-extensions":
				if(! ${?scripts_supported_extensions} ) then
					set scripts_supported_extensions="${value}";
				else
					set scripts_supported_extensions=`printf "(%s|%s)" "${scripts_supported_extensions}" "${value}" | sed -r 's/[()]//g'`;
				endif
				breaksw;
			
			case "normalize";
				if( ${?volume} ) \
					unset volume;
				breaksw;
			
			case "volume":
				switch("${value}")
					case "loudest":
						@ volume=1280;
						breaksw;
					
					case "louder":
						@ volume=1024;
						breaksw;
					
					case "double":
					case "loud":
						@ volume=512;
						breaksw;
					
					case "normal":
						if( ${?volume} ) \
							unset volume;
						breaksw;
					
					case "quieter":
						@ volume=128;
						breaksw;
					
					default:
						if(!( "${value}" != "" && `printf "%s" "${value}" | sed -r 's/^[0-9]{3,}$//'` == "" )) then
							printf "%s is an unsupported %s.  Valid values are: double, normal, quieter, or any number equal to or greater than 100.  E.G.: %s%s=1024.\n" "${value}" "${option}" "${dashes}" "${option}" > /dev/stderr;
						else
							@ volume=${value};
						endif
						breaksw;
				endsw
			
			case "default-files":
				if(! ${?scripts_supported_extensions} ) \
					set scripts_supported_extensions="${scripts_supported_extensions_defaults}";
				breaksw;
			
			case "no-ltrim":
				if( ${?lenth} ) \
					unset lenth;
				if( ${?lenth_set} ) \
					unset lenth_set;
				if( ${?ltrim} ) \
					unset ltrim;
				breaksw;
			
			case "no-lenth":
				if( ${?lenth_set} ) \
					unset lenth lenth_set;
				breaksw;
			
			case "no-rtrim":
				if( ${?rtrim} ) \
					unset rtrim;
				if( ${?lenth_set} ) \
					unset lenth lenth_set;
				breaksw;
			
			case "ltrim":
				if( "${value}" == "" ) then
					if( ${?ltrim} ) \
						unset ltrim;
					breaksw;
				endif
				
				if( "`printf "\""%s"\"" "\""${value}"\"" | sed -r 's/^[0-9]{2}:[0-9]{2}:[0-9]{2}"\$"//'`" != "" ) then
					printf "Invalid %s%s: %s specified, lenth must be formatted as: hh:mm:ss\n" "${dashes}" "${option}" "${value}" > /dev/stderr;
					@ errno=-602;
					goto scripts_main_quit;
					breaksw;
				endif
				
				set ltrim="${value}";
				set value_used;
				breaksw;
			
			case "length":
				if( "${value}" == "" ) then
					if( ${?length} ) \
						unset length;
					if( ${?lengt_set} ) \
						unset length_set;
					breaksw;
				endif
				
				if( "`printf "\""%s"\"" "\""${value}"\"" | sed -r 's/^[0-9]{2}:[0-9]{2}:[0-9]{2}"\$"//'`" != "" ) then
					printf "Invalid %s%s: %s specified, lenth must be formatted as: hh:mm:ss\n" "${dashes}" "${option}" "${value}" > /dev/stderr;
					@ errno=-602;
					goto scripts_main_quit;
					breaksw;
				endif
				
				set length="${value}";
				set length_set="${value}";
				set value_used;
				breaksw;
			
			case "rtrim":
				if( ${?lenth_set} ) \
					unset lenth lenth_set;
				
				if( "${value}" == "" ) then
					if( ${?rtrim} ) \
						unset rtrim;
					breaksw;
				endif
				
				if( "`printf "\""%s"\"" "\""${value}"\"" | sed -r 's/^[0-9]{2}:[0-9]{2}:[0-9]{2}"\$"//'`" != "" ) then
					printf "Invalid %s%s: %s specified, lenth must be formatted as: hh:mm:ss\n" "${dashes}" "${option}" "${value}" > /dev/stderr;
					@ errno=-601;
					goto scripts_main_quit;
					breaksw;
				endif
				
				set rtrim="${value}";
				set value_used;
				breaksw;
			
			case "no-transcode":
				if( ${?transcode} ) \
					unset transcode;
				breaksw;
			
			case "playlist":
				if( "${value}" != "" ) then
					set playlist_type="`printf "\""%s"\"" "\""${value}"\"" | sed -r 's/^(.*)\.([^.]+)"\$"/\2/'`";
				else
					set playlist_type="m3u";
				endif
				
				switch( "${playlist_type}" )
					case "tox":
					case "pls":
					case "m3u":
						breaksw;
					
					default:
						printf "**%s error:** [%s] is an unsupported playlist with an an unsupported playlist type: [%s].\n\nRun: "\`"${scripts_basename} --help"\`" for more information.\n" "${scripts_basename}" "${value}" "${playlist_type}" > /dev/stderr;
						@ errno=-606;
						goto scripts_main_quit;
						breaksw;
				endsw
				
				if( "${value}" != "${playlist_type}" ) then
					set playlist="${value}";
					set value_used;
				else
					set playlist="${scripts_basename}'s ${playlist_type} playlist @ `date '+%c'`.${playlist_type}";
				endif
				
				playlist:new:create.tcsh "${playlist}";
				unset playlist_type;
				set value_used;
				breaksw;
			
			case "no-playlist":
				if(! ${?playlist} ) \
					breaksw;
				
				unset playlist;
				breaksw;
			
			case "transcode":
				switch( "${value}" )
					case "i":
					case "iv":
					case "ivf":
						set transcode="-${value}";
						set value_used;
						breaksw;
					
					case "force":
					case "verbose":
					case "interactive":
						set transcode="--${value}";
						set value_used;
						breaksw;
					
					default:
						set transcode;
						breaksw;
				endsw
				breaksw;
			
			case "force":
				if(! ${?force} ) \
					set force;
				breaksw;
			
			case "combine":
				if(! ${?combine} ) \
					set combine;
				breaksw;
			
			case "verbose":
				if(! ${?be_verbose} ) \
					set be_verbose;
				breaksw;
			
			case "do-not-re-encode":
			case "don't-re-encode":
			case "no-re-encode":
				if( ${?re_encode} ) \
					unset re_encode;
				if( ${?force} ) \
					unset force;
				breaksw;
			
			case "re-encode":
				switch("${value}")
					case "force":
						set value_used;
						if(! ${?force} ) \
							set force;
					default:
						if(! ${?re_encode} ) \
							set re_encode;
				endsw
				breaksw;
			
			case "force":
				if(! ${?force} ) \
					set force;
				if(! ${?re_encode} ) \
					set re_encode;
				breaksw;
			
			case "enable":
				switch("${value}")
					case "verbose":
						if(! ${?be_verbose} ) \
							set be_verbose;
						breaksw;
					
					case "force":
						if(! ${?force} ) \
							set force;
					case "reencode":
					case "re-encode":
						if(! ${?re_encode} ) \
							set re_encode;
						breaksw;
					
					case "transcode":
						if(! ${?transcode} ) \
							set transcode;
						breaksw;
					
					default:
						printf "`printf "\""%s"\"" "\""${option}"\"" | sed -r 's/^(.*)e$/\1ing/'` ${value} is not supported.  See "\`"${scripts_basename} --help"\`"\n";
						@ errno=-607;
						goto scripts_main_quit;
						breaksw;
				endsw
				set value_used;
				breaksw;
			
			case "disable":
				switch("${value}")
					case "verbose":
						if( ${?be_verbose} ) \
							unset be_verbose;
						breaksw;
					
					case "force":
						if( ${?force} ) \
							unset force;
					case "reencode":
					case "re-encode":
						if( ${?re_encode} ) \
							unset re_encode;
						breaksw;
					
					case "transcode":
						if( ${?transcode} ) \
							unset transcode;
						breaksw;
					
					default:
						printf "`printf "\""%s"\"" "\""${option}"\"" | sed -r 's/^(.*)e$/\1ing/'` ${value} is not supported.  See "\`"${scripts_basename} --help"\`"\n";
						@ errno=-608;
						goto scripts_main_quit;
						breaksw;
				endsw
				set value_used;
				breaksw;
			
			case "":
				if( -e "${value}" ) then
					set value_used;
					goto filename_list_append_value;
					breaksw;
				endif
			
			default:
				if( -e "${value}") then
					set value="";
				endif
				
				printf "**%s error:** %s%s%s%s is an unsupported option.\n\nSee "\`"${scripts_basename} -h|--help"\`" for more information.\n" "${scripts_basename}" "${dashes}" "${option}" "${equals}" "${value}" > /dev/stderr;
				@ errno=-609;
				goto scripts_main_quit;
				breaksw;
		endsw
		
		if( ${?arg_shifted} ) then
			if(! ${?value_used} ) \
				@ arg--;
			unset arg_shifted;
		endif
		
		if( ${?value_used} ) \
			unset value_used;
		
		unset argument dashes option equals value;
	end
#goto parse_arg;


parse_argv_quit:
	onintr scripts_main_quit;
	
	unset arg;
	
	if( ${?debug_set} ) \
		unset debug debug_set;
	
	if( ${?debug_arguments} ) \
		goto scripts_main_quit;
	
	if(! ${?process_each_filename} ) \
		goto convert_filename_list;
	
	goto scripts_main_quit;
#goto parse_argv_quit;


filename_list_append_value:
	if(! ${?filename_list} ) \
		set filename_list="${scripts_tmpdir}/.filenames.${scripts_basename}.@`date '+%s'`";
	
	if(! -e "${filename_list}" ) \
		touch "${filename_list}";
	
	set file_count="`wc -l "\""${filename_list}"\"" | sed -r 's/^([0-9]+)(.*)"\$"/\1/'`";
	if(!( ${file_count} > 0 )) then
		printf "%s\n" "${value}" >> "${filename_list}";
	endif
	
	if(! ${?scripts_supported_extensions} ) then
		if( ${?debug} || ${?debug_filelist} ) then
			printf "Adding [%s] to [%s].\nBy running:\n\tfind -L "\""%s"\""" "${value}" "${filename_list}" "${value}";
			if(! ${?supports_hidden_files} ) \
				printf  \! -iregex '.*\/\..*';
			printf "| sort >> "\""%s"\""\n\n" "${filename_list}";
		endif
		if(! ${?supports_hidden_files} ) then
			find -L "${value}" \! -iregex '.*\/\..*' | sort >> "${filename_list}";
		else
			find -L "${value}" | sort >> "${filename_list}";
		endif
		
		if(! ${?process_each_filename} ) then
			goto parse_arg;
		else
			goto convert_filename_list;
		endif
	endif
	
	if( "${scripts_supported_extensions}" == "ogg|mp3|m4a|rm|wma|wav" && ! ${?re_encode} && ! ${?ltrim} && ! ${?rtrim} && ! ${?length} ) then
		set scripts_supported_extensions="mp3|m4a|rm|wma|wav";
	else if( "${scripts_supported_extensions}" == "mp3|m4a|rm|wma|wav" && ( ${?re_encode} || ${?ltrim} || ${?rtrim} || ${?length} ) ) then
		set scripts_supported_extensions="ogg|mp3|m4a|rm|wma|wav";
	endif
	
	if( ${?debug} || ${?debug_filelist} ) then
		if(! -d "${value}" ) then
			printf "Adding [%s] to [%s] if its a supported file type.\nSupported extensions are:\n\t`printf "\""%s"\"" "\""%s"\"" | sed -r 's/\|/,\ /g'`.\n" "${value}" "${filename_list}" "${scripts_supported_extensions}";
		else
			printf "Adding any supported files found under [%s] to [%s].\nSupported extensions are:\n\t`printf "\""%s"\"" "\""%s"\"" | sed -r 's/\|/,\ /g'`.\n" "${value}" "${filename_list}" "${scripts_supported_extensions}";
		endif
		printf "By running:\n\tfind -L "\""${value}"\"" -regextype posix-extended -iregex "\"".*\.(${scripts_supported_extensions})"\"""\$"";
		if(! ${?supports_hidden_files} ) \
			printf " \! -iregex '.*\/\..*'";
		printf " | sort >> "\""%s"\""\n\n" "${filename_list}";
	endif
	
	if(! ${?supports_hidden_files} ) then
		find -L "${value}" -regextype posix-extended -iregex ".*\.(${scripts_supported_extensions})"\$ \! -iregex '.*\/\..*'  | sort >> "${filename_list}";
	else
		find -L "${value}" -regextype posix-extended -iregex ".*\.(${scripts_supported_extensions})"\$ | sort >> "${filename_list}";
	endif
	
	if(! ${?process_each_filename} ) then
		goto parse_arg;
	else
		goto convert_filename_list;
	endif
#goto filename_list_append_value;


