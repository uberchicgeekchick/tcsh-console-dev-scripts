#!/bin/tcsh -f
init:
	set supports_being_source;
	set scripts_name="launcher";
#init:


check_dependencies:
	set dependencies=("${scripts_name}");
	
	foreach dependency(${dependencies})
		foreach dependency("`where '${dependency}'`")
			if(! -x "${dependency}" ) continue;
			
			switch("${dependency}")
				case "${scripts_name}":
				case "./${dependency}":
				case "${TCSH_LAUNCHER_PATH}/${dependency}":
					continue;
					breaksw;
			endsw
			break;
		end
		
		if(! ${?program} )	\
			set program="${dependency}";
		
		if(!( -x ${dependency} && -x ${program} ))	\
			goto missing_dependency;
		
		unset dependency;
	end
	
	unset dependency dependencies;
#check_dependencies:


if_sourced:
	if( `printf '%s' "${0}" | sed -r 's/^[^\.]*(csh)$/\1/'` != "csh" )	\
		goto main;
	
	# for exception handeling when this file is 'sourced'.
	
	# BEGIN: disable source scripts_name.
	if(! ${?supports_being_source} ) then
		set status=-1;
		printf "%s does not support being sourced.\n" "${scripts_name}";
		goto usage;
	endif
	# END: disable source scripts_name.
	
	# BEGIN: source scripts_name support.
	if(! ${?TCSH_RC_SESSION_PATH} )	\
		setenv TCSH_RC_SESSION_PATH "/projects/cli/console.pallet/tcshrc";
	
	if(! ${?TCSH_LAUNCHER_PATH} )	\
		setenv TCSH_LAUNCHER_PATH \$"{TCSH_RC_SESSION_PATH}/../launchers";
	
	source "${TCSH_RC_SESSION_PATH}/argv:check" "${scripts_name}" ${argv};
	if( $args_handled > 0 ) then
		@ args_shifted=0;
		while( $args_shifted < $args_handled )
			@ args_shifted++;
			shift;
		end
		unset args_shifted;
	endif
	unset args_handled;
	
	# START: special handler for when this file is sourced.
	alias ${scripts_name} \$"{TCSH_LAUNCHER_PATH}/${scripts_name}";
	# FINISH: special handler for when this file is sourced.
	
	source "${TCSH_RC_SESSION_PATH}/argv:clean-up" "${scripts_name}";
	
	# END: source scripts_name support.
	
	goto script_main_quit;
#if_sourced:


main:
	set argz="";
	set argc=${#argv};
	if( ${argc} < 1 ) then
		set status=-1;
		goto usage;
	endif
	
	set old_owd="${cwd}";
	cd "`dirname '${0}'`";
	set scripts_path="${cwd}";
	cd "${owd}";
	set escaped_cwd="`printf '%s' '${cwd}' | sed -r 's/\//\\\//g'`";
	set owd="${old_owd}";
	unset old_owd;
	
	set script="${scripts_path}/${scripts_name}";
	
	alias	ex	"ex -E -n -X --noplugin";
	
	goto parse_argv; # exit's via 'usage:' or 'main:'.
#main:


exec:
	set status=0;
	if(! ${?OUTPUT_STDERR} ) then
		( ${program} $argz > /dev/tty ) >& /dev/null;
	else
		( ${program} $argz > /dev/tty ) >& /dev/null;
	endif
	goto script_main_quit;
#exec:


script_main_quit:
	if( ${?scripts_name} ) unset scripts_name;
	if( ${?scripts_path} ) unset scripts_path;
	if( ${?script} ) unset script;
	if( ${?argz} ) unset argz;
	if( ${?debug} ) unset debug;
	if( ${?escaped_cwd} ) unset escaped_cwd;
	if( ${?dependency} ) unset dependency;
	if( ${?dependencies} ) unset dependencies;
	if( ${?usage_displayed} ) unset usage_displayed;
	if( ${?no_exit_on_usage} ) unset no_exit_on_usage;
	if( ${?use_old_owd} ) then
		cd "${owd}";
		set owd="${use_old_owd}";
		unset use_old_owd;
	endif
	exit ${status}
#script_main_quit:


missing_dependency:
	printf "One or more required dependencies couldn't be found.\n\n[%s] couldn't be found.\n\n%s requires: %s" "${dependency}" "${scripts_name}" "${dependencies}";
	set status=-1;
	goto script_main_quit;
#missing_dependency:


usage:
	if(! ${?usage_displayed} ) then
		if(! ${?script} ) then
			printf "Usage:\t%s [-h|--help]...\n\t[-h|--help]\tDisplays this screen.\n" "${scripts_name}";
		else if( "${program}" != "${script}" ) then
			${program} --help;
		endif
	endif
	if(! ${?usage_displayed} ) set usage_displayed;
	if(! ${?no_exit_on_usage} ) then
		goto script_main_quit;
	endif
	goto parse_arg;
#usage:


parse_argv:
	@ argc=${#argv};
	
	if( ${argc} == 0 )	\
		goto exec;
	
	@ arg=0;
	while( $arg < $argc )
		@ arg++;
		if( "$argv[$arg]" != "--debug" ) continue;
		printf "Enabling debug mode; via "\$"argv[%d].\n" $arg;
		set argv[$my_arg]="";
		set debug;
		break;
	end
	if( ! ${?debug} || $arg > 1 )	\
		@ arg=0;
	
	if( ${?debug} ) printf "Checking %s's argv options.  %d total.\n" "${scripts_name}" "${argc}";
#parse_argv:

parse_arg:
	while( $arg < $argc )
		@ arg++;
		
		set equals="";
		set value="`printf "\""$argv[$arg]"\"" | sed -r 's/^([\-]{1,2})([^\=]+)=?['\''"\""]?(.*)['\''"\""]?"\$"/\3/'`";
		if( "${value}" == "$argv[$arg]" ) then
			set value="";
		else
			set equals="=";
		endif
		
		set dashes="`printf "\""$argv[$arg]"\"" | sed -r 's/^([\-]{1,2})([^\=]+)=?['\''"\""]?(.*)['\''"\""]?"\$"/\1/'`";
		if( "${dashes}" == "$argv[$arg]" ) set dashes="";
		
		set option="`printf "\""$argv[$arg]"\"" | sed -r 's/^([\-]{1,2})([^\=]+)=?['\''"\""]?(.*)['\''"\""]?"\$"/\2/'`";
		if( "${option}" == "$argv[$arg]" ) set option="";
		
		if( ${?debug} )		\
			printf "Checking argv #%d (%s).\n\tParsed option: %s%s%s%s\n" "${arg}" "$argv[$arg]" "${dashes}" "${option}" "${equals}" "${value}";
		
		switch("${option}")
			default:
				if(! ${?argz} ) then
					printf "%s%s is an unsupported option.  See %s -h|--help for more information.\n" "${dashes}" "${option}" "${scripts_name}" >& /dev/stderr;
					breaksw;
				endif
				
				if( "${argz}" == "" ) then
					set argz="$argv[$arg]";
				else
					set argz="${argz} $argv[$arg]";
				endif
				breaksw;
		endsw
		unset dashes option equals value;
	end
	goto exec;
#parse_arg:

