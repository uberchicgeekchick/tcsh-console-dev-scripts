<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
  <title>Attribute::Handlers - perldoc.perl.org</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Language" content="en-gb" />
  <link href="../css.css" rel="stylesheet" rev="stylesheet" type="text/css" media="screen" />
</head>

<script language="JavaScript" type="text/javascript" src="../label.js"></script>

<script language="JavaScript">
  pageDepth = 1;
  setPath();
</script>

<body onLoad="showToolbars();loadLabels()">

<div id="pageHeader">
  <div id="pageHeaderLogo">
    <img src="../onion.gif">
  </div>
  <div id="pageHeaderText">
    <a href="http://perldoc.perl.org">perldoc.perl.org</a>
  </div>
</div>

<div id="pageBody">
  <div id="left">
    <div id="leftContent">
      <div id="leftClose">
        <a href="#" onClick="closeLeft()" title="Hide navigation" onmouseover="leftCloseIcon.src='../close_purple.gif';" onmouseout="leftCloseIcon.src='../close_blue.gif';"><img src="../close_blue.gif" name="leftCloseIcon" id="leftCloseIcon" border=0></a>
      </div>
      <h1>Manual:</h1>
      <ul>
        <li><a href="../index-overview.html">Overview</a></li>
        <li><a href="../index-tutorials.html">Tutorials</a></li>
        <li><a href="../index-faq.html">FAQs</a></li>
        <li><a href="../index-history.html">History / Changes</a></li>
        <li><a href="../index-licence.html">Licence</a></li>
      </ul>
      <h2>Reference:</h2>
      <ul>
        <li><a href="../index-language.html">Language</a></li>
        <li><a href="../index-functions.html">Functions</a></li>
        <li><a href="../perlop.html">Operators</a></li>
        <li><a href="../perlvar.html">Special variables</a></li>
        <li><a href="../index-pragmas.html">Pragmas</a></li>
        <li><a href="../index-modules-A.html">Core modules</a></li>
        <li><a href="../index-utilities.html">Utilities</a></li>
        <li><a href="../index-internals.html">Internals</a></li>
        <li><a href="../index-platforms.html">Platform specific</a></li>
      </ul>
      <h2>Links:</h2>
      <ul>
        <li><a href="http://search.cpan.org">CPAN</a></li>
        <li><a href="http://www.perl.com">Perl.com</a></li>
        <li><a href="http://www.perl.org">Perl.org</a></li>
        <li><a href="http://www.pm.org">Perl Mongers</a></li>
        <li><a href="http://www.perlmonks.org">Perl Monks</a></li>
        <li><a href="http://planet.perl.org">Planet Perl</a></li>
        <li><a href="http://use.perl.org">Use Perl</a></li>
      </ul>
      <h2>Contact:</h2>
      <ul>
        <li>Site maintained by<br><a href="http://perl.jonallen.info">Jon Allen</a>
            (<a href="http://perl.jonallen.info">JJ</a>)</li>
        <li class="spaced">Last updated on<br>23 April 2006</li>
	<li class="spaced">See the <a href="http://perl.jonallen.info/projects/perldoc">project page</a> for
	more details</li>
      </ul>
    </div>
  </div>

  <div id="center">  
    <div id="centerContent">
      <div id="contentHeader">
        <div id="contentHeaderLeft"><a href="#" onClick="showLeft()">Show navigation</a></div>
        <div id="contentHeaderCentre">-- Perl 5.8.8 documentation --</div>
        <div id="contentHeaderRight"><a href="#" onClick="showRight()">Show toolbar</a></div>
      </div>
      <div id="breadCrumbs"><a href="../index.html">Home</a> &gt; <a href="../index-modules-A.html">Core modules</a> &gt; <a href="../index-modules-A.html">A</a> &gt; Attribute::Handlers</div>
      <script language="JavaScript">fromSearch();</script>
      <div id="contentBody"><div class="title_container"><div class="page_title">Attribute::Handlers</div><div class="pdf_link"><a href="../Attribute/Handlers.pdf">View as PDF</a></div><div class="pdf_img_link"><a href="../Attribute/Handlers.pdf"><img src="../pdficon.gif" border=0></a></div></div><ul><li><a href="#NAME">NAME</a><li><a href="#VERSION">VERSION</a><li><a href="#SYNOPSIS">SYNOPSIS</a><li><a href="#DESCRIPTION">DESCRIPTION</a><ul><li><a href="#Typed-lexicals">Typed lexicals</a><li><a href="#Type-specific-attribute-handlers">Type-specific attribute handlers</a><li><a href="#Non-interpretive-attribute-handlers">Non-interpretive attribute handlers</a><li><a href="#Phase-specific-attribute-handlers">Phase-specific attribute handlers</a><li><a href="#Attributes-as-'tie'-interfaces">Attributes as <code class="inline"><a class="l_k" href="../functions/tie.html">tie</a></code> interfaces</a></ul><li><a href="#EXAMPLES">EXAMPLES</a><li><a href="#DIAGNOSTICS">DIAGNOSTICS</a><li><a href="#AUTHOR">AUTHOR</a><li><a href="#BUGS">BUGS</a><li><a href="#COPYRIGHT">COPYRIGHT</a></ul><a name="NAME"></a><h1>NAME</h1>
<p>Attribute::Handlers - Simpler definition of attribute handlers</p>
<a name="VERSION"></a><h1>VERSION</h1>
<p>This document describes version 0.78 of Attribute::Handlers,
released October 5, 2002.</p>
<a name="SYNOPSIS"></a><h1>SYNOPSIS</h1>
<pre class="verbatim"><a name="package-MyClass"></a>	package <span class="i">MyClass</span><span class="sc">;</span>
	<a class="l_k" href="../functions/require.html">require</a> <span class="v">v5.6.0</span><span class="sc">;</span>
	<a class="l_k" href="../functions/use.html">use</a> <a class="l_w" href="../Attribute/Handlers.html">Attribute::Handlers</a><span class="sc">;</span>
	<a class="l_k" href="../functions/no.html">no</a> <a class="l_w" href="../warnings.html">warnings</a> <span class="q">&#39;redefine&#39;</span><span class="sc">;</span></pre>
<pre class="verbatim">	sub Good : ATTR(SCALAR) {
		my ($package, $symbol, $referent, $attr, $data) = @_;</pre><pre class="verbatim">		<span class="c"># Invoked for any scalar variable with a :Good attribute,</span>
		<span class="c"># provided the variable was declared in MyClass (or</span>
		<span class="c"># a derived class) or typed to MyClass.</span></pre>
<pre class="verbatim">		# Do whatever to $referent here (executed in CHECK phase).
		...
	}</pre><pre class="verbatim"><a name="Bad"></a>	sub <span class="m">Bad</span> <span class="co">:</span> <span class="i">ATTR</span><span class="s">(</span>SCALAR<span class="s">)</span> <span class="s">{</span>
		<span class="c"># Invoked for any scalar variable with a :Bad attribute,</span>
		<span class="c"># provided the variable was declared in MyClass (or</span>
		<span class="c"># a derived class) or typed to MyClass.</span>
		...
	<span class="s">}</span></pre>
<pre class="verbatim"><a name="Good"></a>	sub <span class="m">Good</span> <span class="co">:</span> <span class="i">ATTR</span><span class="s">(</span>ARRAY<span class="s">)</span> <span class="s">{</span>
		<span class="c"># Invoked for any array variable with a :Good attribute,</span>
		<span class="c"># provided the variable was declared in MyClass (or</span>
		<span class="c"># a derived class) or typed to MyClass.</span>
		...
	<span class="s">}</span></pre>
<pre class="verbatim"><a name="Good"></a>	sub <span class="m">Good</span> <span class="co">:</span> <span class="i">ATTR</span><span class="s">(</span>HASH<span class="s">)</span> <span class="s">{</span>
		<span class="c"># Invoked for any hash variable with a :Good attribute,</span>
		<span class="c"># provided the variable was declared in MyClass (or</span>
		<span class="c"># a derived class) or typed to MyClass.</span>
		...
	<span class="s">}</span></pre>
<pre class="verbatim"><a name="Ugly"></a>	sub <span class="m">Ugly</span> <span class="co">:</span> <span class="i">ATTR</span><span class="s">(</span>CODE<span class="s">)</span> <span class="s">{</span>
		<span class="c"># Invoked for any subroutine declared in MyClass (or a </span>
		<span class="c"># derived class) with an :Ugly attribute.</span>
		...
	<span class="s">}</span></pre>
<pre class="verbatim"><a name="Omni"></a>	sub <span class="m">Omni</span> <span class="co">:</span> ATTR <span class="s">{</span>
		<span class="c"># Invoked for any scalar, array, hash, or subroutine</span>
		<span class="c"># with an :Omni attribute, provided the variable or</span>
		<span class="c"># subroutine was declared in MyClass (or a derived class)</span>
		<span class="c"># or the variable was typed to MyClass.</span>
		<span class="c"># Use ref($_[2]) to determine what kind of referent it was.</span>
		...
	<span class="s">}</span></pre>
<pre class="verbatim">	<a class="l_k" href="../functions/use.html">use</a> <a class="l_w" href="../Attribute/Handlers.html">Attribute::Handlers</a> autotie <span class="cm">=&gt;</span> <span class="s">{</span> Cycle <span class="cm">=&gt;</span> Tie::Cycle <span class="s">}</span><span class="sc">;</span></pre>
<pre class="verbatim">	<a class="l_k" href="../functions/my.html">my</a> <span class="i">$next</span> <span class="co">:</span> <span class="i">Cycle</span><span class="s">(</span><span class="s">[</span><span class="q">&#39;A&#39;</span>..<span class="q">&#39;Z&#39;</span><span class="s">]</span><span class="s">)</span><span class="sc">;</span></pre>
<a name="DESCRIPTION"></a><h1>DESCRIPTION</h1>
<p>This module, when inherited by a package, allows that package's class to
define attribute handler subroutines for specific attributes. Variables
and subroutines subsequently defined in that package, or in packages
derived from that package may be given attributes with the same names as
the attribute handler subroutines, which will then be called in one of
the compilation phases (i.e. in a <code class="inline">BEGIN</code>
, <code class="inline">CHECK</code>
, <code class="inline">INIT</code>
, or <code class="inline">END</code>

block).</p>
<p>To create a handler, define it as a subroutine with the same name as
the desired attribute, and declare the subroutine itself with the  
attribute <code class="inline"><span class="j">:</span>ATTR</code>
. For example:</p>
<pre class="verbatim"><a name="package-LoudDecl"></a>	package <span class="i">LoudDecl</span><span class="sc">;</span>
	<a class="l_k" href="../functions/use.html">use</a> <a class="l_w" href="../Attribute/Handlers.html">Attribute::Handlers</a><span class="sc">;</span></pre>
<pre class="verbatim"><a name="Loud"></a>	sub <span class="m">Loud</span> <span class="co">:</span>ATTR <span class="s">{</span>
		<a class="l_k" href="../functions/my.html">my</a> <span class="s">(</span><span class="i">$package</span><span class="cm">,</span> <span class="i">$symbol</span><span class="cm">,</span> <span class="i">$referent</span><span class="cm">,</span> <span class="i">$attr</span><span class="cm">,</span> <span class="i">$data</span><span class="cm">,</span> <span class="i">$phase</span><span class="s">)</span> = <span class="i">@_</span><span class="sc">;</span>
		<a class="l_k" href="../functions/print.html">print</a> <span class="i">STDERR</span>
			<a class="l_k" href="../functions/ref.html">ref</a><span class="s">(</span><span class="i">$referent</span><span class="s">)</span><span class="cm">,</span> <span class="q">&quot; &quot;</span><span class="cm">,</span>
			<span class="i">*</span>{<span class="i">$symbol</span>}{NAME}<span class="cm">,</span> <span class="q">&quot; &quot;</span><span class="cm">,</span>
			<span class="q">&quot;($referent) &quot;</span><span class="cm">,</span> <span class="q">&quot;was just declared &quot;</span><span class="cm">,</span>
			<span class="q">&quot;and ascribed the ${attr} attribute &quot;</span><span class="cm">,</span>
			<span class="q">&quot;with data ($data)\n&quot;</span><span class="cm">,</span>
			<span class="q">&quot;in phase $phase\n&quot;</span><span class="sc">;</span>
	<span class="s">}</span></pre>
<p>This creates a handler for the attribute <code class="inline"><span class="j">:</span>Loud</code>
 in the class LoudDecl.
Thereafter, any subroutine declared with a <code class="inline"><span class="j">:</span>Loud</code>
 attribute in the class
LoudDecl:</p>
<pre class="verbatim"><a name="package-LoudDecl"></a>	package <span class="i">LoudDecl</span><span class="sc">;</span></pre>
<pre class="verbatim"><a name="foo"></a>	sub <span class="m">foo</span><span class="co">:</span> Loud <span class="s">{</span>...<span class="s">}</span></pre>
<p>causes the above handler to be invoked, and passed:</p>
<ul>
<li><a name="%5b0%5d"></a><b>[0]</b>
<p>the name of the package into which it was declared;</p>
</li>
<li><a name="%5b1%5d"></a><b>[1]</b>
<p>a reference to the symbol table entry (typeglob) containing the subroutine;</p>
</li>
<li><a name="%5b2%5d"></a><b>[2]</b>
<p>a reference to the subroutine;</p>
</li>
<li><a name="%5b3%5d"></a><b>[3]</b>
<p>the name of the attribute;</p>
</li>
<li><a name="%5b4%5d"></a><b>[4]</b>
<p>any data associated with that attribute;</p>
</li>
<li><a name="%5b5%5d"></a><b>[5]</b>
<p>the name of the phase in which the handler is being invoked.</p>
</li>
</ul>
<p>Likewise, declaring any variables with the <code class="inline"><span class="j">:</span>Loud</code>
 attribute within the
package:</p>
<pre class="verbatim"><a name="package-LoudDecl"></a>        package <span class="i">LoudDecl</span><span class="sc">;</span></pre>
<pre class="verbatim">        <a class="l_k" href="../functions/my.html">my</a> <span class="i">$foo</span> <span class="co">:</span>Loud<span class="sc">;</span>
        <a class="l_k" href="../functions/my.html">my</a> <span class="i">@foo</span> <span class="co">:</span>Loud<span class="sc">;</span>
        <a class="l_k" href="../functions/my.html">my</a> <span class="i">%foo</span> <span class="co">:</span>Loud<span class="sc">;</span></pre>
<p>will cause the handler to be called with a similar argument list (except,
of course, that <code class="inline"><span class="i">$_</span>[<span class="n">2</span>]</code>
 will be a reference to the variable).</p>
<p>The package name argument will typically be the name of the class into
which the subroutine was declared, but it may also be the name of a derived
class (since handlers are inherited).</p>
<p>If a lexical variable is given an attribute, there is no symbol table to 
which it belongs, so the symbol table argument (<code class="inline"><span class="i">$_</span>[<span class="n">1</span>]</code>
) is set to the
string <code class="inline"><span class="q">&#39;LEXICAL&#39;</span></code>
 in that case. Likewise, ascribing an attribute to
an anonymous subroutine results in a symbol table argument of <code class="inline"><span class="q">&#39;ANON&#39;</span></code>
.</p>
<p>The data argument passes in the value (if any) associated with the 
attribute. For example, if <code class="inline"><span class="i">&amp;foo</span></code>
 had been declared:</p>
<pre class="verbatim"><a name="foo"></a>        sub <span class="m">foo</span> <span class="co">:</span><span class="i">Loud</span><span class="s">(</span><span class="q">&quot;turn it up to 11, man!&quot;</span><span class="s">)</span> <span class="s">{</span>...<span class="s">}</span></pre>
<p>then the string <code class="inline"><span class="q">&quot;turn it up to 11, man!&quot;</span></code>
 would be passed as the
last argument.</p>
<p>Attribute::Handlers makes strenuous efforts to convert
the data argument (<code class="inline"><span class="i">$_</span>[<span class="n">4</span>]</code>
) to a useable form before passing it to
the handler (but see <a href="#Non-interpretive-attribute-handlers">"Non-interpretive attribute handlers"</a>).
For example, all of these:</p>
<pre class="verbatim"><a name="foo"></a>        sub <span class="m">foo</span> <span class="co">:</span><span class="i">Loud</span><span class="s">(</span>till<span class="cm">=&gt;</span>ears<span class="cm">=&gt;</span>are<span class="cm">=&gt;</span>bleeding<span class="s">)</span> <span class="s">{</span>...<span class="s">}</span>
<a name="foo-1"></a>        sub <span class="m">foo</span> <span class="co">:</span><span class="i">Loud</span><span class="s">(</span><span class="s">[</span><span class="q">&#39;till&#39;</span><span class="cm">,</span><span class="q">&#39;ears&#39;</span><span class="cm">,</span><span class="q">&#39;are&#39;</span><span class="cm">,</span><span class="q">&#39;bleeding&#39;</span><span class="s">]</span><span class="s">)</span> <span class="s">{</span>...<span class="s">}</span>
<a name="foo-2"></a>        sub <span class="m">foo</span> <span class="co">:</span><span class="i">Loud</span><span class="s">(</span><span class="q">qw/till ears are bleeding/</span><span class="s">)</span> <span class="s">{</span>...<span class="s">}</span>
<a name="foo-3"></a>        sub <span class="m">foo</span> <span class="co">:</span><span class="i">Loud</span><span class="s">(</span><span class="q">qw/my, ears, are, bleeding/</span><span class="s">)</span> <span class="s">{</span>...<span class="s">}</span>
<a name="foo-4"></a>        sub <span class="m">foo</span> <span class="co">:</span><span class="i">Loud</span><span class="s">(</span>till<span class="cm">,</span>ears<span class="cm">,</span>are<span class="cm">,</span>bleeding<span class="s">)</span> <span class="s">{</span>...<span class="s">}</span></pre>
<p>causes it to pass <code class="inline"><span class="s">[</span><span class="q">&#39;till&#39;</span><span class="cm">,</span><span class="q">&#39;ears&#39;</span><span class="cm">,</span><span class="q">&#39;are&#39;</span><span class="cm">,</span><span class="q">&#39;bleeding&#39;</span><span class="s">]</span></code>
 as the handler's
data argument. However, if the data can't be parsed as valid Perl, then
it is passed as an uninterpreted string. For example:</p>
<pre class="verbatim">        sub foo :Loud(my,ears,are,bleeding) {...}
        sub foo :Loud(qw/my ears are bleeding) {...}</pre><p>cause the strings <code class="inline"><span class="q">&#39;my,ears,are,bleeding&#39;</span></code>
 and <code class="inline"><span class="q">&#39;qw/my ears are bleeding&#39;</span></code>

respectively to be passed as the data argument.</p>
<p>If the attribute has only a single associated scalar data value, that value is
passed as a scalar. If multiple values are associated, they are passed as an
array reference. If no value is associated with the attribute, <code class="inline"><a class="l_k" href="../functions/undef.html">undef</a></code> is
passed.</p>
<a name="Typed-lexicals"></a><h2>Typed lexicals</h2>
<p>Regardless of the package in which it is declared, if a lexical variable is
ascribed an attribute, the handler that is invoked is the one belonging to
the package to which it is typed. For example, the following declarations:</p>
<pre class="verbatim"><a name="package-OtherClass"></a>        package <span class="i">OtherClass</span><span class="sc">;</span></pre>
<pre class="verbatim">        <a class="l_k" href="../functions/my.html">my</a> LoudDecl <span class="i">$loudobj</span> <span class="co">:</span> Loud<span class="sc">;</span>
        <a class="l_k" href="../functions/my.html">my</a> LoudDecl <span class="i">@loudobjs</span> <span class="co">:</span> Loud<span class="sc">;</span>
        <a class="l_k" href="../functions/my.html">my</a> LoudDecl <span class="i">%loudobjex</span> <span class="co">:</span> Loud<span class="sc">;</span></pre>
<p>causes the LoudDecl::Loud handler to be invoked (even if OtherClass also
defines a handler for <code class="inline"><span class="j">:</span>Loud</code>
 attributes).</p>
<a name="Type-specific-attribute-handlers"></a><h2>Type-specific attribute handlers</h2>
<p>If an attribute handler is declared and the <code class="inline"><span class="j">:</span>ATTR</code>
 specifier is
given the name of a built-in type (<code class="inline">SCALAR</code>
, <code class="inline">ARRAY</code>
, <code class="inline">HASH</code>
, or <code class="inline">CODE</code>
),
the handler is only applied to declarations of that type. For example,
the following definition:</p>
<pre class="verbatim"><a name="package-LoudDecl"></a>        package <span class="i">LoudDecl</span><span class="sc">;</span></pre>
<pre class="verbatim"><a name="RealLoud"></a>        sub <span class="m">RealLoud</span> <span class="co">:</span><span class="i">ATTR</span><span class="s">(</span>SCALAR<span class="s">)</span> <span class="s">{</span> <a class="l_k" href="../functions/print.html">print</a> <span class="q">&quot;Yeeeeow!&quot;</span> <span class="s">}</span></pre>
<p>creates an attribute handler that applies only to scalars:</p>
<pre class="verbatim"><a name="package-Painful"></a>        package <span class="i">Painful</span><span class="sc">;</span>
        <a class="l_k" href="../functions/use.html">use</a> <a class="l_w" href="../base.html">base</a> LoudDecl<span class="sc">;</span></pre>
<pre class="verbatim">        <a class="l_k" href="../functions/my.html">my</a> <span class="i">$metal</span> <span class="co">:</span> RealLoud<span class="sc">;</span>           <span class="c"># invokes &amp;LoudDecl::RealLoud</span>
        <a class="l_k" href="../functions/my.html">my</a> <span class="i">@metal</span> <span class="co">:</span> RealLoud<span class="sc">;</span>           <span class="c"># error: unknown attribute</span>
        <a class="l_k" href="../functions/my.html">my</a> <span class="i">%metal</span> <span class="co">:</span> RealLoud<span class="sc">;</span>           <span class="c"># error: unknown attribute</span>
<a name="metal"></a>        sub <span class="m">metal</span> <span class="co">:</span> RealLoud <span class="s">{</span>...<span class="s">}</span>      <span class="c"># error: unknown attribute</span></pre>
<p>You can, of course, declare separate handlers for these types as well
(but you'll need to specify <code class="inline"><a class="l_k" href="../functions/no.html">no</a> <a class="l_w" href="../warnings.html">warnings</a> <span class="q">&#39;redefine&#39;</span></code>
 to do it quietly):</p>
<pre class="verbatim"><a name="package-LoudDecl"></a>        package <span class="i">LoudDecl</span><span class="sc">;</span>
        <a class="l_k" href="../functions/use.html">use</a> <a class="l_w" href="../Attribute/Handlers.html">Attribute::Handlers</a><span class="sc">;</span>
        <a class="l_k" href="../functions/no.html">no</a> <a class="l_w" href="../warnings.html">warnings</a> <span class="q">&#39;redefine&#39;</span><span class="sc">;</span></pre>
<pre class="verbatim"><a name="RealLoud"></a>        sub <span class="m">RealLoud</span> <span class="co">:</span><span class="i">ATTR</span><span class="s">(</span>SCALAR<span class="s">)</span> <span class="s">{</span> <a class="l_k" href="../functions/print.html">print</a> <span class="q">&quot;Yeeeeow!&quot;</span> <span class="s">}</span>
<a name="RealLoud-1"></a>        sub <span class="m">RealLoud</span> <span class="co">:</span><span class="i">ATTR</span><span class="s">(</span>ARRAY<span class="s">)</span> <span class="s">{</span> <a class="l_k" href="../functions/print.html">print</a> <span class="q">&quot;Urrrrrrrrrr!&quot;</span> <span class="s">}</span>
<a name="RealLoud-2"></a>        sub <span class="m">RealLoud</span> <span class="co">:</span><span class="i">ATTR</span><span class="s">(</span>HASH<span class="s">)</span> <span class="s">{</span> <a class="l_k" href="../functions/print.html">print</a> <span class="q">&quot;Arrrrrgggghhhhhh!&quot;</span> <span class="s">}</span>
<a name="RealLoud-3"></a>        sub <span class="m">RealLoud</span> <span class="co">:</span><span class="i">ATTR</span><span class="s">(</span>CODE<span class="s">)</span> <span class="s">{</span> croak <span class="q">&quot;Real loud sub torpedoed&quot;</span> <span class="s">}</span></pre>
<p>You can also explicitly indicate that a single handler is meant to be
used for all types of referents like so:</p>
<pre class="verbatim"><a name="package-LoudDecl"></a>        package <span class="i">LoudDecl</span><span class="sc">;</span>
        <a class="l_k" href="../functions/use.html">use</a> <a class="l_w" href="../Attribute/Handlers.html">Attribute::Handlers</a><span class="sc">;</span></pre>
<pre class="verbatim"><a name="SeriousLoud"></a>        sub <span class="m">SeriousLoud</span> <span class="co">:</span><span class="i">ATTR</span><span class="s">(</span>ANY<span class="s">)</span> <span class="s">{</span> <a class="l_k" href="../functions/warn.html">warn</a> <span class="q">&quot;Hearing loss imminent&quot;</span> <span class="s">}</span></pre>
<p>(I.e. <code class="inline"><span class="i">ATTR</span><span class="s">(</span>ANY<span class="s">)</span></code>
 is a synonym for <code class="inline"><span class="j">:</span>ATTR</code>
).</p>
<a name="Non-interpretive-attribute-handlers"></a><h2>Non-interpretive attribute handlers</h2>
<p>Occasionally the strenuous efforts Attribute::Handlers makes to convert
the data argument (<code class="inline"><span class="i">$_</span>[<span class="n">4</span>]</code>
) to a useable form before passing it to
the handler get in the way.</p>
<p>You can turn off that eagerness-to-help by declaring
an attribute handler with the keyword <code class="inline">RAWDATA</code>
. For example:</p>
<pre class="verbatim"><a name="Raw"></a>        sub <span class="m">Raw</span>          <span class="co">:</span> <span class="i">ATTR</span><span class="s">(</span>RAWDATA<span class="s">)</span> <span class="s">{</span>...<span class="s">}</span>
<a name="Nekkid"></a>        sub <span class="m">Nekkid</span>       <span class="co">:</span> <span class="i">ATTR</span><span class="s">(</span>SCALAR<span class="cm">,</span>RAWDATA<span class="s">)</span> <span class="s">{</span>...<span class="s">}</span>
<a name="Au::Naturale"></a>        sub <span class="m">Au::Naturale</span> <span class="co">:</span> <span class="i">ATTR</span><span class="s">(</span>RAWDATA<span class="cm">,</span>ANY<span class="s">)</span> <span class="s">{</span>...<span class="s">}</span></pre>
<p>Then the handler makes absolutely no attempt to interpret the data it
receives and simply passes it as a string:</p>
<pre class="verbatim">        <a class="l_k" href="../functions/my.html">my</a> <span class="i">$power</span> <span class="co">:</span> <span class="i">Raw</span><span class="s">(</span><span class="n">1</span>..<span class="n">100</span><span class="s">)</span><span class="sc">;</span>        <span class="c"># handlers receives &quot;1..100&quot;</span></pre>
<a name="Phase-specific-attribute-handlers"></a><h2>Phase-specific attribute handlers</h2>
<p>By default, attribute handlers are called at the end of the compilation
phase (in a <code class="inline">CHECK</code>
 block). This seems to be optimal in most cases because
most things that can be defined are defined by that point but nothing has
been executed.</p>
<p>However, it is possible to set up attribute handlers that are called at
other points in the program's compilation or execution, by explicitly
stating the phase (or phases) in which you wish the attribute handler to
be called. For example:</p>
<pre class="verbatim"><a name="Early"></a>        sub <span class="m">Early</span>    <span class="co">:</span><span class="i">ATTR</span><span class="s">(</span>SCALAR<span class="cm">,</span>BEGIN<span class="s">)</span> <span class="s">{</span>...<span class="s">}</span>
<a name="Normal"></a>        sub <span class="m">Normal</span>   <span class="co">:</span><span class="i">ATTR</span><span class="s">(</span>SCALAR<span class="cm">,</span>CHECK<span class="s">)</span> <span class="s">{</span>...<span class="s">}</span>
<a name="Late"></a>        sub <span class="m">Late</span>     <span class="co">:</span><span class="i">ATTR</span><span class="s">(</span>SCALAR<span class="cm">,</span>INIT<span class="s">)</span> <span class="s">{</span>...<span class="s">}</span>
<a name="Final"></a>        sub <span class="m">Final</span>    <span class="co">:</span><span class="i">ATTR</span><span class="s">(</span>SCALAR<span class="cm">,</span>END<span class="s">)</span> <span class="s">{</span>...<span class="s">}</span>
<a name="Bookends"></a>        sub <span class="m">Bookends</span> <span class="co">:</span><span class="i">ATTR</span><span class="s">(</span>SCALAR<span class="cm">,</span>BEGIN<span class="cm">,</span>END<span class="s">)</span> <span class="s">{</span>...<span class="s">}</span></pre>
<p>As the last example indicates, a handler may be set up to be (re)called in
two or more phases. The phase name is passed as the handler's final argument.</p>
<p>Note that attribute handlers that are scheduled for the <code class="inline">BEGIN</code>
 phase
are handled as soon as the attribute is detected (i.e. before any
subsequently defined <code class="inline">BEGIN</code>
 blocks are executed).</p>
<a name="Attributes-as-'tie'-interfaces"></a><h2>Attributes as <code class="inline"><a class="l_k" href="../functions/tie.html">tie</a></code> interfaces</h2>
<p>Attributes make an excellent and intuitive interface through which to tie
variables. For example:</p>
<pre class="verbatim">        <a class="l_k" href="../functions/use.html">use</a> <a class="l_w" href="../Attribute/Handlers.html">Attribute::Handlers</a><span class="sc">;</span>
        <a class="l_k" href="../functions/use.html">use</a> Tie::Cycle<span class="sc">;</span></pre>
<pre class="verbatim"><a name="UNIVERSAL::Cycle"></a>        sub <span class="m">UNIVERSAL::Cycle</span> <span class="co">:</span> <span class="i">ATTR</span><span class="s">(</span>SCALAR<span class="s">)</span> <span class="s">{</span>
                <a class="l_k" href="../functions/my.html">my</a> <span class="s">(</span><span class="i">$package</span><span class="cm">,</span> <span class="i">$symbol</span><span class="cm">,</span> <span class="i">$referent</span><span class="cm">,</span> <span class="i">$attr</span><span class="cm">,</span> <span class="i">$data</span><span class="cm">,</span> <span class="i">$phase</span><span class="s">)</span> = <span class="i">@_</span><span class="sc">;</span>
                <span class="i">$data</span> = <span class="s">[</span> <span class="i">$data</span> <span class="s">]</span> unless <a class="l_k" href="../functions/ref.html">ref</a> <span class="i">$data</span> eq <span class="q">&#39;ARRAY&#39;</span><span class="sc">;</span>
                <a class="l_k" href="../functions/tie.html">tie</a> <span class="i">$$referent</span><span class="cm">,</span> <span class="q">&#39;Tie::Cycle&#39;</span><span class="cm">,</span> <span class="i">$data</span><span class="sc">;</span>
        <span class="s">}</span></pre>
<pre class="verbatim">        <span class="c"># and thereafter...</span></pre>
<pre class="verbatim"><a name="package-main"></a>        package <span class="i">main</span><span class="sc">;</span></pre>
<pre class="verbatim">        <a class="l_k" href="../functions/my.html">my</a> <span class="i">$next</span> <span class="co">:</span> <span class="i">Cycle</span><span class="s">(</span><span class="q">&#39;A&#39;</span>..<span class="q">&#39;Z&#39;</span><span class="s">)</span><span class="sc">;</span>     <span class="c"># $next is now a tied variable</span></pre>
<pre class="verbatim">        while <span class="s">(</span>&lt;&gt;<span class="s">)</span> <span class="s">{</span>
                <a class="l_k" href="../functions/print.html">print</a> <span class="i">$next</span><span class="sc">;</span>
        <span class="s">}</span></pre>
<p>Note that, because the <code class="inline">Cycle</code>
 attribute receives its arguments in the
<code class="inline"><span class="i">$data</span></code>
 variable, if the attribute is given a list of arguments, <code class="inline"><span class="i">$data</span></code>

will consist of a single array reference; otherwise, it will consist of the
single argument directly. Since Tie::Cycle requires its cycling values to
be passed as an array reference, this means that we need to wrap
non-array-reference arguments in an array constructor:</p>
<pre class="verbatim">        <span class="i">$data</span> = <span class="s">[</span> <span class="i">$data</span> <span class="s">]</span> unless <a class="l_k" href="../functions/ref.html">ref</a> <span class="i">$data</span> eq <span class="q">&#39;ARRAY&#39;</span><span class="sc">;</span></pre>
<p>Typically, however, things are the other way around: the tieable class expects
its arguments as a flattened list, so the attribute looks like:</p>
<pre class="verbatim"><a name="UNIVERSAL::Cycle"></a>        sub <span class="m">UNIVERSAL::Cycle</span> <span class="co">:</span> <span class="i">ATTR</span><span class="s">(</span>SCALAR<span class="s">)</span> <span class="s">{</span>
                <a class="l_k" href="../functions/my.html">my</a> <span class="s">(</span><span class="i">$package</span><span class="cm">,</span> <span class="i">$symbol</span><span class="cm">,</span> <span class="i">$referent</span><span class="cm">,</span> <span class="i">$attr</span><span class="cm">,</span> <span class="i">$data</span><span class="cm">,</span> <span class="i">$phase</span><span class="s">)</span> = <span class="i">@_</span><span class="sc">;</span>
                <a class="l_k" href="../functions/my.html">my</a> <span class="i">@data</span> = <a class="l_k" href="../functions/ref.html">ref</a> <span class="i">$data</span> eq <span class="q">&#39;ARRAY&#39;</span> ? <span class="i">@$data</span> <span class="co">:</span> <span class="i">$data</span><span class="sc">;</span>
                <a class="l_k" href="../functions/tie.html">tie</a> <span class="i">$$referent</span><span class="cm">,</span> <span class="q">&#39;Tie::Whatever&#39;</span><span class="cm">,</span> <span class="i">@data</span><span class="sc">;</span>
        <span class="s">}</span></pre>
<p>This software pattern is so widely applicable that Attribute::Handlers
provides a way to automate it: specifying <code class="inline"><span class="q">&#39;autotie&#39;</span></code>
 in the
<code class="inline"><a class="l_k" href="../functions/use.html">use</a> <a class="l_w" href="../Attribute/Handlers.html">Attribute::Handlers</a></code>
 statement. So, the cycling example,
could also be written:</p>
<pre class="verbatim">        <a class="l_k" href="../functions/use.html">use</a> <a class="l_w" href="../Attribute/Handlers.html">Attribute::Handlers</a> autotie <span class="cm">=&gt;</span> <span class="s">{</span> Cycle <span class="cm">=&gt;</span> <span class="q">&#39;Tie::Cycle&#39;</span> <span class="s">}</span><span class="sc">;</span></pre>
<pre class="verbatim">        <span class="c"># and thereafter...</span></pre>
<pre class="verbatim"><a name="package-main"></a>        package <span class="i">main</span><span class="sc">;</span></pre>
<pre class="verbatim">        <a class="l_k" href="../functions/my.html">my</a> <span class="i">$next</span> <span class="co">:</span> <span class="i">Cycle</span><span class="s">(</span><span class="s">[</span><span class="q">&#39;A&#39;</span>..<span class="q">&#39;Z&#39;</span><span class="s">]</span><span class="s">)</span><span class="sc">;</span>     <span class="c"># $next is now a tied variable</span></pre>
<pre class="verbatim">        while (&lt;&gt;) {
                print $next;</pre><p>Note that we now have to pass the cycling values as an array reference,
since the <code class="inline">autotie</code>
 mechanism passes <code class="inline"><a class="l_k" href="../functions/tie.html">tie</a></code> a list of arguments as a list
(as in the Tie::Whatever example), <i>not</i> as an array reference (as in
the original Tie::Cycle example at the start of this section).</p>
<p>The argument after <code class="inline"><span class="q">&#39;autotie&#39;</span></code>
 is a reference to a hash in which each key is
the name of an attribute to be created, and each value is the class to which
variables ascribed that attribute should be tied.</p>
<p>Note that there is no longer any need to import the Tie::Cycle module --
Attribute::Handlers takes care of that automagically. You can even pass
arguments to the module's <code class="inline"><a class="l_k" href="../functions/import.html">import</a></code> subroutine, by appending them to the
class name. For example:</p>
<pre class="verbatim">	<a class="l_k" href="../functions/use.html">use</a> <a class="l_w" href="../Attribute/Handlers.html">Attribute::Handlers</a>
		autotie <span class="cm">=&gt;</span> <span class="s">{</span> Dir <span class="cm">=&gt;</span> <span class="q">&#39;Tie::Dir qw(DIR_UNLINK)&#39;</span> <span class="s">}</span><span class="sc">;</span></pre>
<p>If the attribute name is unqualified, the attribute is installed in the
current package. Otherwise it is installed in the qualifier's package:</p>
<pre class="verbatim"><a name="package-Here"></a>        package <span class="i">Here</span><span class="sc">;</span></pre>
<pre class="verbatim">        <a class="l_k" href="../functions/use.html">use</a> <a class="l_w" href="../Attribute/Handlers.html">Attribute::Handlers</a> autotie <span class="cm">=&gt;</span> <span class="s">{</span>
                Other::Good <span class="cm">=&gt;</span> Tie::SecureHash<span class="cm">,</span> <span class="c"># tie attr installed in Other::</span>
                        Bad <span class="cm">=&gt;</span> Tie::Taxes<span class="cm">,</span>      <span class="c"># tie attr installed in Here::</span>
            UNIVERSAL::Ugly <span class="cm">=&gt;</span> Software::Patent <span class="c"># tie attr installed everywhere</span>
        <span class="s">}</span><span class="sc">;</span></pre>
<p>Autoties are most commonly used in the module to which they actually tie, 
and need to export their attributes to any module that calls them. To
facilitate this, Attribute::Handlers recognizes a special "pseudo-class" --
<code class="inline">__CALLER__</code>
, which may be specified as the qualifier of an attribute:</p>
<pre class="verbatim">        package Tie::Me::Kangaroo:Down::Sport;</pre><pre class="verbatim">        <a class="l_k" href="../functions/use.html">use</a> <a class="l_w" href="../Attribute/Handlers.html">Attribute::Handlers</a> autotie <span class="cm">=&gt;</span> <span class="s">{</span> <span class="q">&#39;__CALLER__::Roo&#39;</span> <span class="cm">=&gt;</span> __PACKAGE__ <span class="s">}</span><span class="sc">;</span></pre>
<p>This causes Attribute::Handlers to define the <code class="inline">Roo</code>
 attribute in the package
that imports the Tie::Me::Kangaroo:Down::Sport module.</p>
<p>Note that it is important to quote the __CALLER__::Roo identifier because
a bug in perl 5.8 will refuse to parse it and cause an unknown error.</p>
<h3>Passing the tied object to <code class="inline"><a class="l_k" href="../functions/tie.html">tie</a></code></h3>
<p>Occasionally it is important to pass a reference to the object being tied
to the TIESCALAR, TIEHASH, etc. that ties it. </p>
<p>The <code class="inline">autotie</code>
 mechanism supports this too. The following code:</p>
<pre class="verbatim">	<a class="l_k" href="../functions/use.html">use</a> <a class="l_w" href="../Attribute/Handlers.html">Attribute::Handlers</a> autotieref <span class="cm">=&gt;</span> <span class="s">{</span> Selfish <span class="cm">=&gt;</span> Tie::Selfish <span class="s">}</span><span class="sc">;</span>
	<a class="l_k" href="../functions/my.html">my</a> <span class="i">$var</span> <span class="co">:</span> <span class="i">Selfish</span><span class="s">(</span><span class="i">@args</span><span class="s">)</span><span class="sc">;</span></pre>
<p>has the same effect as:</p>
<pre class="verbatim">	<a class="l_k" href="../functions/tie.html">tie</a> <a class="l_k" href="../functions/my.html">my</a> <span class="i">$var</span><span class="cm">,</span> <span class="q">&#39;Tie::Selfish&#39;</span><span class="cm">,</span> <span class="i">@args</span><span class="sc">;</span></pre>
<p>But when <code class="inline"><span class="q">&quot;autotieref&quot;</span></code>
 is used instead of <code class="inline"><span class="q">&quot;autotie&quot;</span></code>
:</p>
<pre class="verbatim">	<a class="l_k" href="../functions/use.html">use</a> <a class="l_w" href="../Attribute/Handlers.html">Attribute::Handlers</a> autotieref <span class="cm">=&gt;</span> <span class="s">{</span> Selfish <span class="cm">=&gt;</span> Tie::Selfish <span class="s">}</span><span class="sc">;</span>
	<a class="l_k" href="../functions/my.html">my</a> <span class="i">$var</span> <span class="co">:</span> <span class="i">Selfish</span><span class="s">(</span><span class="i">@args</span><span class="s">)</span><span class="sc">;</span></pre>
<p>the effect is to pass the <code class="inline"><a class="l_k" href="../functions/tie.html">tie</a></code> call an extra reference to the variable
being tied:</p>
<pre class="verbatim">        <a class="l_k" href="../functions/tie.html">tie</a> <a class="l_k" href="../functions/my.html">my</a> <span class="i">$var</span><span class="cm">,</span> <span class="q">&#39;Tie::Selfish&#39;</span><span class="cm">,</span> \<span class="i">$var</span><span class="cm">,</span> <span class="i">@args</span><span class="sc">;</span></pre>
<a name="EXAMPLES"></a><h1>EXAMPLES</h1>
<p>If the class shown in <a href="http://search.cpan.org/perldoc/SYNOPSIS">SYNOPSIS</a> were placed in the MyClass.pm
module, then the following code:</p>
<pre class="verbatim"><a name="package-main"></a>        package <span class="i">main</span><span class="sc">;</span>
        <a class="l_k" href="../functions/use.html">use</a> MyClass<span class="sc">;</span></pre>
<pre class="verbatim">        <a class="l_k" href="../functions/my.html">my</a> MyClass <span class="i">$slr</span> <span class="co">:</span>Good <span class="co">:</span><span class="i">Bad</span><span class="s">(</span><span class="n">1</span>**<span class="n">1</span>-<span class="n">1</span><span class="s">)</span> <span class="co">:</span><span class="i">Omni</span><span class="s">(</span>-vorous<span class="s">)</span><span class="sc">;</span></pre>
<pre class="verbatim"><a name="package-SomeOtherClass"></a>        package <span class="i">SomeOtherClass</span><span class="sc">;</span>
        <a class="l_k" href="../functions/use.html">use</a> <a class="l_w" href="../base.html">base</a> MyClass<span class="sc">;</span></pre>
<pre class="verbatim"><a name="tent"></a>        sub <span class="m">tent</span> <span class="s">{</span> <span class="q">&#39;acle&#39;</span> <span class="s">}</span></pre>
<pre class="verbatim">        sub fn :Ugly(sister) :Omni('po',tent()) {...}
        my @arr :Good :Omni(s/cie/nt/);
        my %hsh :Good(q/bye) :Omni(q/bus/);</pre><p>would cause the following handlers to be invoked:</p>
<pre class="verbatim">        <span class="c"># my MyClass $slr :Good :Bad(1**1-1) :Omni(-vorous);</span></pre>
<pre class="verbatim">        MyClass::Good:ATTR(SCALAR)( 'MyClass',          # class
                                    'LEXICAL',          # no typeglob
                                    \$slr,              # referent
                                    'Good',             # attr name
                                    undef               # no attr data
                                    'CHECK',            # compiler phase
                                  );</pre><pre class="verbatim">        MyClass::Bad:ATTR(SCALAR)( 'MyClass',           # class
                                   'LEXICAL',           # no typeglob
                                   \$slr,               # referent
                                   'Bad',               # attr name
                                   0                    # eval'd attr data
                                   'CHECK',             # compiler phase
                                 );</pre><pre class="verbatim">        MyClass::Omni:ATTR(SCALAR)( 'MyClass',          # class
                                    'LEXICAL',          # no typeglob
                                    \$slr,              # referent
                                    'Omni',             # attr name
                                    '-vorous'           # eval'd attr data
                                    'CHECK',            # compiler phase
                                  );</pre><pre class="verbatim">        <span class="c"># sub fn :Ugly(sister) :Omni(&#39;po&#39;,tent()) {...}</span></pre>
<pre class="verbatim">        MyClass::UGLY:ATTR(CODE)( 'SomeOtherClass',     # class
                                  \*SomeOtherClass::fn, # typeglob
                                  \&amp;SomeOtherClass::fn, # referent
                                  'Ugly',               # attr name
                                  'sister'              # eval'd attr data
                                  'CHECK',              # compiler phase
                                );</pre><pre class="verbatim">        MyClass::Omni:ATTR(CODE)( 'SomeOtherClass',     # class
                                  \*SomeOtherClass::fn, # typeglob
                                  \&amp;SomeOtherClass::fn, # referent
                                  'Omni',               # attr name
                                  ['po','acle']         # eval'd attr data
                                  'CHECK',              # compiler phase
                                );</pre><pre class="verbatim">        <span class="c"># my @arr :Good :Omni(s/cie/nt/);</span></pre>
<pre class="verbatim">        MyClass::Good:ATTR(ARRAY)( 'SomeOtherClass',    # class
                                   'LEXICAL',           # no typeglob
                                   \@arr,               # referent
                                   'Good',              # attr name
                                   undef                # no attr data
                                   'CHECK',             # compiler phase
                                 );</pre><pre class="verbatim">        MyClass::Omni:ATTR(ARRAY)( 'SomeOtherClass',    # class
                                   'LEXICAL',           # no typeglob
                                   \@arr,               # referent
                                   'Omni',              # attr name
                                   ""                   # eval'd attr data 
                                   'CHECK',             # compiler phase
                                 );</pre><pre class="verbatim">        # my %hsh :Good(q/bye) :Omni(q/bus/);
                                  
        MyClass::Good:ATTR(HASH)( 'SomeOtherClass',     # class
                                  'LEXICAL',            # no typeglob
                                  \%hsh,                # referent
                                  'Good',               # attr name
                                  'q/bye'               # raw attr data
                                  'CHECK',              # compiler phase
                                );
                        
        MyClass::Omni:ATTR(HASH)( 'SomeOtherClass',     # class
                                  'LEXICAL',            # no typeglob
                                  \%hsh,                # referent
                                  'Omni',               # attr name
                                  'bus'                 # eval'd attr data
                                  'CHECK',              # compiler phase
                                );</pre><p>Installing handlers into UNIVERSAL, makes them...err..universal.
For example:</p>
<pre class="verbatim"><a name="package-Descriptions"></a>        package <span class="i">Descriptions</span><span class="sc">;</span>
        <a class="l_k" href="../functions/use.html">use</a> <a class="l_w" href="../Attribute/Handlers.html">Attribute::Handlers</a><span class="sc">;</span></pre>
<pre class="verbatim">        <a class="l_k" href="../functions/my.html">my</a> <span class="i">%name</span><span class="sc">;</span>
<a name="name"></a>        sub <span class="m">name</span> <span class="s">{</span> <a class="l_k" href="../functions/return.html">return</a> <span class="i">$name</span>{<span class="i">$_</span>[<span class="n">2</span>]}||<span class="i">*</span>{<span class="i">$_</span>[<span class="n">1</span>]}{NAME} <span class="s">}</span></pre>
<pre class="verbatim"><a name="UNIVERSAL::Name"></a>        sub <span class="m">UNIVERSAL::Name</span> <span class="co">:</span>ATTR <span class="s">{</span>
                <span class="i">$name</span>{<span class="i">$_</span>[<span class="n">2</span>]} = <span class="i">$_</span>[<span class="n">4</span>]<span class="sc">;</span>
        <span class="s">}</span></pre>
<pre class="verbatim"><a name="UNIVERSAL::Purpose"></a>        sub <span class="m">UNIVERSAL::Purpose</span> <span class="co">:</span>ATTR <span class="s">{</span>
                <a class="l_k" href="../functions/print.html">print</a> <span class="i">STDERR</span> <span class="q">&quot;Purpose of &quot;</span><span class="cm">,</span> <span class="i">&amp;name</span><span class="cm">,</span> <span class="q">&quot; is $_[4]\n&quot;</span><span class="sc">;</span>
        <span class="s">}</span></pre>
<pre class="verbatim"><a name="UNIVERSAL::Unit"></a>        sub <span class="m">UNIVERSAL::Unit</span> <span class="co">:</span>ATTR <span class="s">{</span>
                <a class="l_k" href="../functions/print.html">print</a> <span class="i">STDERR</span> <span class="i">&amp;name</span><span class="cm">,</span> <span class="q">&quot; measured in $_[4]\n&quot;</span><span class="sc">;</span>
        <span class="s">}</span></pre>
<p>Let's you write:</p>
<pre class="verbatim">        <a class="l_k" href="../functions/use.html">use</a> Descriptions<span class="sc">;</span></pre>
<pre class="verbatim">        <a class="l_k" href="../functions/my.html">my</a> <span class="i">$capacity</span> <span class="co">:</span> <span class="i">Name</span><span class="s">(</span>capacity<span class="s">)</span>
                     <span class="co">:</span> <span class="i">Purpose</span><span class="s">(</span>to store max storage capacity for files<span class="s">)</span>
                     <span class="co">:</span> <span class="i">Unit</span><span class="s">(</span>Gb<span class="s">)</span><span class="sc">;</span></pre>
<pre class="verbatim"><a name="package-Other"></a>        package <span class="i">Other</span><span class="sc">;</span></pre>
<pre class="verbatim"><a name="foo"></a>        sub <span class="m">foo</span> <span class="co">:</span> <span class="i">Purpose</span><span class="s">(</span>to <span class="i">foo</span> all data before barring it<span class="s">)</span> <span class="s">{</span> <span class="s">}</span></pre>
<pre class="verbatim">        <span class="c"># etc.</span></pre>
<a name="DIAGNOSTICS"></a><h1>DIAGNOSTICS</h1>
<ul>
<li><a name="'Bad-attribute-type%3a-ATTR(%25s)'"></a><b><code class="inline">Bad attribute type: ATTR(%s)</code></b>
<p>An attribute handler was specified with an <code class="inline"><span class="j">:</span><span class="i">ATTR</span><span class="s">(</span>ref_type<span class="s">)</span></code>
, but the
type of referent it was defined to handle wasn't one of the five permitted:
<code class="inline">SCALAR</code>
, <code class="inline">ARRAY</code>
, <code class="inline">HASH</code>
, <code class="inline">CODE</code>
, or <code class="inline">ANY</code>
.</p>
</li>
<li><a name="'Attribute-handler-%25s-doesn't-handle-%25s-attributes'"></a><b><code class="inline">Attribute handler %s doesn't handle %s attributes</code></b>
<p>A handler for attributes of the specified name <i>was</i> defined, but not
for the specified type of declaration. Typically encountered whe trying
to apply a <code class="inline">VAR</code>
 attribute handler to a subroutine, or a <code class="inline">SCALAR</code>

attribute handler to some other type of variable.</p>
</li>
<li><a name="'Declaration-of-%25s-attribute-in-package-%25s-may-clash-with-future-reserved-word'"></a><b><code class="inline">Declaration of %s attribute in package %s may clash with future reserved word</code></b>
<p>A handler for an attributes with an all-lowercase name was declared. An
attribute with an all-lowercase name might have a meaning to Perl
itself some day, even though most don't yet. Use a mixed-case attribute
name, instead.</p>
</li>
<li><a name="'Can't-have-two-ATTR-specifiers-on-one-subroutine'"></a><b><code class="inline">Can&#39;t have two ATTR specifiers on one subroutine</code>
</b>
<p>You just can't, okay?
Instead, put all the specifications together with commas between them
in a single <code class="inline"><span class="i">ATTR</span><span class="s">(</span>specification<span class="s">)</span></code>
.</p>
</li>
<li><a name="'Can't-autotie-a-%25s'"></a><b><code class="inline">Can&#39;t autotie a <span class="i">%s</span></code>
</b>
<p>You can only declare autoties for types <code class="inline"><span class="q">&quot;SCALAR&quot;</span></code>
, <code class="inline"><span class="q">&quot;ARRAY&quot;</span></code>
, and
<code class="inline"><span class="q">&quot;HASH&quot;</span></code>
. They're the only things (apart from typeglobs -- which are
not declarable) that Perl can tie.</p>
</li>
<li><a name="'Internal-error%3a-%25s-symbol-went-missing'"></a><b><code class="inline">Internal error: %s symbol went missing</code></b>
<p>Something is rotten in the state of the program. An attributed
subroutine ceased to exist between the point it was declared and the point
at which its attribute handler(s) would have been called.</p>
</li>
<li><a name="'Won't-be-able-to-apply-END-handler'"></a><b><code class="inline">Won&#39;t be able to apply END handler</code>
</b>
<p>You have defined an END handler for an attribute that is being applied
to a lexical variable.  Since the variable may not be available during END
this won't happen.</p>
</li>
</ul>
<a name="AUTHOR"></a><h1>AUTHOR</h1>
<p>Damian Conway (damian@conway.org)</p>
<a name="BUGS"></a><h1>BUGS</h1>
<p>There are undoubtedly serious bugs lurking somewhere in code this funky :-)
Bug reports and other feedback are most welcome.</p>
<a name="COPYRIGHT"></a><h1>COPYRIGHT</h1>
<pre class="verbatim">         Copyright (c) 2001, Damian Conway. All Rights Reserved.
       This module is free software. It may be used, redistributed
           and/or modified under the same terms as Perl itself.
</pre></div>
      <div id="contentFooter"><a href="http://www.perl.org"><img src="../perlpowered.png" border=0></a></div>
    </div>
  </div>

  <div id="right">
    <div id="rightContent">
      <div id="leftClose">
        <a href="#" onClick="closeRight()" title="Hide toolbar" onmouseover="rightCloseIcon.src='../close_purple.gif';" onmouseout="rightCloseIcon.src='../close_blue.gif';"><img src="../close_blue.gif" name="rightCloseIcon" id="rightCloseIcon" border=0></a>
      </div>
      <h1>Search:</h1>
      <p>
        <form action="../search.html" name="perldoc_search">
	  <input type="text" name="q" size="10" class="grey"><br>
	  <!--<select name="r"><option value="1" selected>Go to top result<option value="0">Show results list</select>-->
	</form>
      </p>
      <h2>Labels:</h2>
      <p>
        <a href="#" onClick="addLabel('Attribute::Handlers','Attribute/Handlers.html')">Add this page</a>
      </p>
      <div class="labels" id="labels">
      </div>
    </div>
  </div>

</div>

</body>
</html>
