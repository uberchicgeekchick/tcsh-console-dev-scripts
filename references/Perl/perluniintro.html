<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
  <title>perluniintro - perldoc.perl.org</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Language" content="en-gb" />
  <link href="css.css" rel="stylesheet" rev="stylesheet" type="text/css" media="screen" />
</head>

<script language="JavaScript" type="text/javascript" src="label.js"></script>

<script language="JavaScript">
  pageDepth = 0;
  setPath();
</script>

<body onLoad="showToolbars();loadLabels()">

<div id="pageHeader">
  <div id="pageHeaderLogo">
    <img src="onion.gif">
  </div>
  <div id="pageHeaderText">
    <a href="http://perldoc.perl.org">perldoc.perl.org</a>
  </div>
</div>

<div id="pageBody">
  <div id="left">
    <div id="leftContent">
      <div id="leftClose">
        <a href="#" onClick="closeLeft()" title="Hide navigation" onmouseover="leftCloseIcon.src='close_purple.gif';" onmouseout="leftCloseIcon.src='close_blue.gif';"><img src="close_blue.gif" name="leftCloseIcon" id="leftCloseIcon" border=0></a>
      </div>
      <h1>Manual:</h1>
      <ul>
        <li><a href="index-overview.html">Overview</a></li>
        <li><a href="index-tutorials.html">Tutorials</a></li>
        <li><a href="index-faq.html">FAQs</a></li>
        <li><a href="index-history.html">History / Changes</a></li>
        <li><a href="index-licence.html">Licence</a></li>
      </ul>
      <h2>Reference:</h2>
      <ul>
        <li><a href="index-language.html">Language</a></li>
        <li><a href="index-functions.html">Functions</a></li>
        <li><a href="perlop.html">Operators</a></li>
        <li><a href="perlvar.html">Special variables</a></li>
        <li><a href="index-pragmas.html">Pragmas</a></li>
        <li><a href="index-modules-A.html">Core modules</a></li>
        <li><a href="index-utilities.html">Utilities</a></li>
        <li><a href="index-internals.html">Internals</a></li>
        <li><a href="index-platforms.html">Platform specific</a></li>
      </ul>
      <h2>Links:</h2>
      <ul>
        <li><a href="http://search.cpan.org">CPAN</a></li>
        <li><a href="http://www.perl.com">Perl.com</a></li>
        <li><a href="http://www.perl.org">Perl.org</a></li>
        <li><a href="http://www.pm.org">Perl Mongers</a></li>
        <li><a href="http://www.perlmonks.org">Perl Monks</a></li>
        <li><a href="http://planet.perl.org">Planet Perl</a></li>
        <li><a href="http://use.perl.org">Use Perl</a></li>
      </ul>
      <h2>Contact:</h2>
      <ul>
        <li>Site maintained by<br><a href="http://perl.jonallen.info">Jon Allen</a>
            (<a href="http://perl.jonallen.info">JJ</a>)</li>
        <li class="spaced">Last updated on<br>23 April 2006</li>
	<li class="spaced">See the <a href="http://perl.jonallen.info/projects/perldoc">project page</a> for
	more details</li>
      </ul>
    </div>
  </div>

  <div id="center">  
    <div id="centerContent">
      <div id="contentHeader">
        <div id="contentHeaderLeft"><a href="#" onClick="showLeft()">Show navigation</a></div>
        <div id="contentHeaderCentre">-- Perl 5.8.8 documentation --</div>
        <div id="contentHeaderRight"><a href="#" onClick="showRight()">Show toolbar</a></div>
      </div>
      <div id="breadCrumbs"><a href="index.html">Home</a> &gt; <a href="index-language.html">Language reference</a> &gt; perluniintro</div>
      <script language="JavaScript">fromSearch();</script>
      <div id="contentBody"><div class="title_container"><div class="page_title">perluniintro</div><div class="pdf_link"><a href="perluniintro.pdf">View as PDF</a></div><div class="pdf_img_link"><a href="perluniintro.pdf"><img src="pdficon.gif" border=0></a></div></div><ul><li><a href="#NAME">NAME</a><li><a href="#DESCRIPTION">DESCRIPTION</a><ul><li><a href="#Unicode">Unicode</a><li><a href="#Perl's-Unicode-Support">Perl's Unicode Support</a><li><a href="#Perl's-Unicode-Model">Perl's Unicode Model</a><li><a href="#Unicode-and-EBCDIC">Unicode and EBCDIC</a><li><a href="#Creating-Unicode">Creating Unicode</a><li><a href="#Handling-Unicode">Handling Unicode</a><li><a href="#Legacy-Encodings">Legacy Encodings</a><li><a href="#Unicode-I%2fO">Unicode I/O</a><li><a href="#Displaying-Unicode-As-Text">Displaying Unicode As Text</a><li><a href="#Special-Cases">Special Cases</a><li><a href="#Advanced-Topics">Advanced Topics</a><li><a href="#Miscellaneous">Miscellaneous</a><li><a href="#Questions-With-Answers">Questions With Answers</a><li><a href="#Hexadecimal-Notation">Hexadecimal Notation</a><li><a href="#Further-Resources">Further Resources</a></ul><li><a href="#UNICODE-IN-OLDER-PERLS">UNICODE IN OLDER PERLS</a><li><a href="#SEE-ALSO">SEE ALSO</a><li><a href="#ACKNOWLEDGMENTS">ACKNOWLEDGMENTS</a><li><a href="#AUTHOR%2c-COPYRIGHT%2c-AND-LICENSE">AUTHOR, COPYRIGHT, AND LICENSE</a></ul><a name="NAME"></a><h1>NAME</h1>
<p>perluniintro - Perl Unicode introduction</p>
<a name="DESCRIPTION"></a><h1>DESCRIPTION</h1>
<p>This document gives a general idea of Unicode and how to use Unicode
in Perl.</p>
<a name="Unicode"></a><h2>Unicode</h2>
<p>Unicode is a character set standard which plans to codify all of the
writing systems of the world, plus many other symbols.</p>
<p>Unicode and ISO/IEC 10646 are coordinated standards that provide code
points for characters in almost all modern character set standards,
covering more than 30 writing systems and hundreds of languages,
including all commercially-important modern languages.  All characters
in the largest Chinese, Japanese, and Korean dictionaries are also
encoded. The standards will eventually cover almost all characters in
more than 250 writing systems and thousands of languages.
Unicode 1.0 was released in October 1991, and 4.0 in April 2003.</p>
<p>A Unicode <i>character</i> is an abstract entity.  It is not bound to any
particular integer width, especially not to the C language <code class="inline">char</code>
.
Unicode is language-neutral and display-neutral: it does not encode the
language of the text and it does not define fonts or other graphical
layout details.  Unicode operates on characters and on text built from
those characters.</p>
<p>Unicode defines characters like <code class="inline">LATIN CAPITAL LETTER A</code>
 or <code class="inline">GREEK
SMALL LETTER ALPHA</code>
 and unique numbers for the characters, in this
case 0x0041 and 0x03B1, respectively.  These unique numbers are called
<i>code points</i>.</p>
<p>The Unicode standard prefers using hexadecimal notation for the code
points.  If numbers like <code class="inline"><span class="n">0x0041</span></code>
 are unfamiliar to you, take a peek
at a later section, <a href="#Hexadecimal-Notation">"Hexadecimal Notation"</a>.  The Unicode standard
uses the notation <code class="inline">U+0041 LATIN CAPITAL LETTER A</code>, to give the
hexadecimal code point and the normative name of the character.</p>
<p>Unicode also defines various <i>properties</i> for the characters, like
"uppercase" or "lowercase", "decimal digit", or "punctuation";
these properties are independent of the names of the characters.
Furthermore, various operations on the characters like uppercasing,
lowercasing, and collating (sorting) are defined.</p>
<p>A Unicode character consists either of a single code point, or a
<i>base character</i> (like <code class="inline">LATIN CAPITAL LETTER A</code>
), followed by one or
more <i>modifiers</i> (like <code class="inline">COMBINING ACUTE ACCENT</code>
).  This sequence of
base character and modifiers is called a <i>combining character
sequence</i>.</p>
<p>Whether to call these combining character sequences "characters"
depends on your point of view. If you are a programmer, you probably
would tend towards seeing each element in the sequences as one unit,
or "character".  The whole sequence could be seen as one "character",
however, from the user's point of view, since that's probably what it
looks like in the context of the user's language.</p>
<p>With this "whole sequence" view of characters, the total number of
characters is open-ended. But in the programmer's "one unit is one
character" point of view, the concept of "characters" is more
deterministic.  In this document, we take that second  point of view:
one "character" is one Unicode code point, be it a base character or
a combining character.</p>
<p>For some combinations, there are <i>precomposed</i> characters.
<code class="inline">LATIN CAPITAL LETTER A WITH ACUTE</code>
, for example, is defined as
a single code point.  These precomposed characters are, however,
only available for some combinations, and are mainly
meant to support round-trip conversions between Unicode and legacy
standards (like the ISO 8859).  In the general case, the composing
method is more extensible.  To support conversion between
different compositions of the characters, various <i>normalization
forms</i> to standardize representations are also defined.</p>
<p>Because of backward compatibility with legacy encodings, the "a unique
number for every character" idea breaks down a bit: instead, there is
"at least one number for every character".  The same character could
be represented differently in several legacy encodings.  The
converse is also not true: some code points do not have an assigned
character.  Firstly, there are unallocated code points within
otherwise used blocks.  Secondly, there are special Unicode control
characters that do not represent true characters.</p>
<p>A common myth about Unicode is that it would be "16-bit", that is,
Unicode is only represented as <code class="inline"><span class="n">0x10000</span></code>
 (or 65536) characters from
<code class="inline"><span class="n">0x0000</span></code>
 to <code class="inline"><span class="n">0xFFFF</span></code>
.  <b>This is untrue.</b>  Since Unicode 2.0 (July
1996), Unicode has been defined all the way up to 21 bits (<code class="inline"><span class="n">0x10FFFF</span></code>
),
and since Unicode 3.1 (March 2001), characters have been defined
beyond <code class="inline"><span class="n">0xFFFF</span></code>
.  The first <code class="inline"><span class="n">0x10000</span></code>
 characters are called the
<i>Plane 0</i>, or the <i>Basic Multilingual Plane</i> (BMP).  With Unicode
3.1, 17 (yes, seventeen) planes in all were defined--but they are
nowhere near full of defined characters, yet.</p>
<p>Another myth is that the 256-character blocks have something to
do with languages--that each block would define the characters used
by a language or a set of languages.  <b>This is also untrue.</b>
The division into blocks exists, but it is almost completely
accidental--an artifact of how the characters have been and
still are allocated.  Instead, there is a concept called <i>scripts</i>,
which is more useful: there is <code class="inline">Latin</code>
 script, <code class="inline">Greek</code>
 script, and
so on.  Scripts usually span varied parts of several blocks.
For further information see <a href="Unicode/UCD.html">Unicode::UCD</a>.</p>
<p>The Unicode code points are just abstract numbers.  To input and
output these abstract numbers, the numbers must be <i>encoded</i> or
<i>serialised</i> somehow.  Unicode defines several <i>character encoding
forms</i>, of which <i>UTF-8</i> is perhaps the most popular.  UTF-8 is a
variable length encoding that encodes Unicode characters as 1 to 6
bytes (only 4 with the currently defined characters).  Other encodings
include UTF-16 and UTF-32 and their big- and little-endian variants
(UTF-8 is byte-order independent) The ISO/IEC 10646 defines the UCS-2
and UCS-4 encoding forms.</p>
<p>For more information about encodings--for instance, to learn what
<i>surrogates</i> and <i>byte order marks</i> (BOMs) are--see <a href="perlunicode.html">perlunicode</a>.</p>
<a name="Perl's-Unicode-Support"></a><h2>Perl's Unicode Support</h2>
<p>Starting from Perl 5.6.0, Perl has had the capacity to handle Unicode
natively.  Perl 5.8.0, however, is the first recommended release for
serious Unicode work.  The maintenance release 5.6.1 fixed many of the
problems of the initial Unicode implementation, but for example
regular expressions still do not work with Unicode in 5.6.1.</p>
<p><b>Starting from Perl 5.8.0, the use of <code class="inline"><a class="l_k" href="functions/use.html">use</a> <a class="l_w" href="utf8.html">utf8</a></code>
 is no longer
necessary.</b> In earlier releases the <code class="inline"><a class="l_w" href="utf8.html">utf8</a></code> pragma was used to declare
that operations in the current block or file would be Unicode-aware.
This model was found to be wrong, or at least clumsy: the "Unicodeness"
is now carried with the data, instead of being attached to the
operations.  Only one case remains where an explicit <code class="inline"><a class="l_k" href="functions/use.html">use</a> <a class="l_w" href="utf8.html">utf8</a></code>
 is
needed: if your Perl script itself is encoded in UTF-8, you can use
UTF-8 in your identifier names, and in string and regular expression
literals, by saying <code class="inline"><a class="l_k" href="functions/use.html">use</a> <a class="l_w" href="utf8.html">utf8</a></code>
.  This is not the default because
scripts with legacy 8-bit data in them would break.  See <a href="utf8.html">utf8</a>.</p>
<a name="Perl's-Unicode-Model"></a><h2>Perl's Unicode Model</h2>
<p>Perl supports both pre-5.6 strings of eight-bit native bytes, and
strings of Unicode characters.  The principle is that Perl tries to
keep its data as eight-bit bytes for as long as possible, but as soon
as Unicodeness cannot be avoided, the data is transparently upgraded
to Unicode.</p>
<p>Internally, Perl currently uses either whatever the native eight-bit
character set of the platform (for example Latin-1) is, defaulting to
UTF-8, to encode Unicode strings. Specifically, if all code points in
the string are <code class="inline"><span class="n">0xFF</span></code>
 or less, Perl uses the native eight-bit
character set.  Otherwise, it uses UTF-8.</p>
<p>A user of Perl does not normally need to know nor care how Perl
happens to encode its internal strings, but it becomes relevant when
outputting Unicode strings to a stream without a PerlIO layer -- one with
the "default" encoding.  In such a case, the raw bytes used internally
(the native character set or UTF-8, as appropriate for each string)
will be used, and a "Wide character" warning will be issued if those
strings contain a character beyond 0x00FF.</p>
<p>For example,</p>
<pre class="verbatim">      perl -e <span class="q">&#39;print &quot;\x{DF}\n&quot;, &quot;\x{0100}\x{DF}\n&quot;&#39;</span>              </pre>
<p>produces a fairly useless mixture of native bytes and UTF-8, as well
as a warning:</p>
<pre class="verbatim">     Wide character in <a class="l_k" href="functions/print.html">print</a> <span class="i">at</span> ...</pre>
<p>To output UTF-8, use the <code class="inline"><span class="j">:</span><a class="l_w" href="utf8.html">utf8</a></code>
 output layer.  Prepending</p>
<pre class="verbatim">      <a class="l_k" href="functions/binmode.html">binmode</a><span class="s">(</span>STDOUT<span class="cm">,</span> <span class="q">&quot;:utf8&quot;</span><span class="s">)</span><span class="sc">;</span></pre>
<p>to this sample program ensures that the output is completely UTF-8,
and removes the program's warning.</p>
<p>You can enable automatic UTF-8-ification of your standard file
handles, default <code class="inline"><a class="l_k" href="functions/open.html">open()</a></code> layer, and <code class="inline"><span class="i">@ARGV</span></code>
 by using either
the <code class="inline">-C</code>
 command line switch or the <code class="inline">PERL_UNICODE</code>
 environment
variable, see <a href="perlrun.html">perlrun</a> for the documentation of the <code class="inline">-C</code>
 switch.</p>
<p>Note that this means that Perl expects other software to work, too:
if Perl has been led to believe that STDIN should be UTF-8, but then
STDIN coming in from another command is not UTF-8, Perl will complain
about the malformed UTF-8.</p>
<p>All features that combine Unicode and I/O also require using the new
PerlIO feature.  Almost all Perl 5.8 platforms do use PerlIO, though:
you can see whether yours is by running "perl -V" and looking for
<code class="inline">useperlio=define</code>
.</p>
<a name="Unicode-and-EBCDIC"></a><h2>Unicode and EBCDIC</h2>
<p>Perl 5.8.0 also supports Unicode on EBCDIC platforms.  There,
Unicode support is somewhat more complex to implement since
additional conversions are needed at every step.  Some problems
remain, see <a href="perlebcdic.html">perlebcdic</a> for details.</p>
<p>In any case, the Unicode support on EBCDIC platforms is better than
in the 5.6 series, which didn't work much at all for EBCDIC platform.
On EBCDIC platforms, the internal Unicode encoding form is UTF-EBCDIC
instead of UTF-8.  The difference is that as UTF-8 is "ASCII-safe" in
that ASCII characters encode to UTF-8 as-is, while UTF-EBCDIC is
"EBCDIC-safe".</p>
<a name="Creating-Unicode"></a><h2>Creating Unicode</h2>
<p>To create Unicode characters in literals for code points above <code class="inline"><span class="n">0xFF</span></code>
,
use the <code class="inline">\<span class="i">x</span><span class="s">{</span>...<span class="s">}</span></code>
 notation in double-quoted strings:</p>
<pre class="verbatim">    <a class="l_k" href="functions/my.html">my</a> <span class="i">$smiley</span> = <span class="q">&quot;\x{263a}&quot;</span><span class="sc">;</span></pre>
<p>Similarly, it can be used in regular expression literals</p>
<pre class="verbatim">    <span class="i">$smiley</span> =~ <span class="q">/\x{263a}/</span><span class="sc">;</span></pre>
<p>At run-time you can use <code class="inline"><a class="l_k" href="functions/chr.html">chr()</a></code>:</p>
<pre class="verbatim">    <a class="l_k" href="functions/my.html">my</a> <span class="i">$hebrew_alef</span> = <a class="l_k" href="functions/chr.html">chr</a><span class="s">(</span><span class="n">0x05d0</span><span class="s">)</span><span class="sc">;</span></pre>
<p>See <a href="#Further-Resources">"Further Resources"</a> for how to find all these numeric codes.</p>
<p>Naturally, <code class="inline"><a class="l_k" href="functions/ord.html">ord()</a></code> will do the reverse: it turns a character into
a code point.</p>
<p>Note that <code class="inline">\x..</code>
 (no <code class="inline"><span class="s">{</span><span class="s">}</span></code>
 and only two hexadecimal digits), <code class="inline">\<span class="i">x</span><span class="s">{</span>...<span class="s">}</span></code>
,
and <code class="inline"><a class="l_k" href="functions/chr.html">chr(...)</a></code> for arguments less than <code class="inline"><span class="n">0x100</span></code>
 (decimal 256)
generate an eight-bit character for backward compatibility with older
Perls.  For arguments of <code class="inline"><span class="n">0x100</span></code>
 or more, Unicode characters are
always produced. If you want to force the production of Unicode
characters regardless of the numeric value, use <code class="inline"><a class="l_k" href="functions/pack.html">pack</a><span class="s">(</span><span class="q">&quot;U&quot;</span><span class="cm">,</span> ...<span class="s">)</span></code>

instead of <code class="inline">\x..</code>
, <code class="inline">\<span class="i">x</span><span class="s">{</span>...<span class="s">}</span></code>
, or <code class="inline"><a class="l_k" href="functions/chr.html">chr()</a></code>.</p>
<p>You can also use the <code class="inline"><a class="l_w" href="charnames.html">charnames</a></code> pragma to invoke characters
by name in double-quoted strings:</p>
<pre class="verbatim">    <a class="l_k" href="functions/use.html">use</a> <a class="l_w" href="charnames.html">charnames</a> <span class="q">&#39;:full&#39;</span><span class="sc">;</span>
    <a class="l_k" href="functions/my.html">my</a> <span class="i">$arabic_alef</span> = <span class="q">&quot;\N{ARABIC LETTER ALEF}&quot;</span><span class="sc">;</span></pre>
<p>And, as mentioned above, you can also <code class="inline"><a class="l_k" href="functions/pack.html">pack()</a></code> numbers into Unicode
characters:</p>
<pre class="verbatim">   <a class="l_k" href="functions/my.html">my</a> <span class="i">$georgian_an</span>  = <a class="l_k" href="functions/pack.html">pack</a><span class="s">(</span><span class="q">&quot;U&quot;</span><span class="cm">,</span> <span class="n">0x10a0</span><span class="s">)</span><span class="sc">;</span></pre>
<p>Note that both <code class="inline">\<span class="i">x</span><span class="s">{</span>...<span class="s">}</span></code>
 and <code class="inline">\<span class="i">N</span><span class="s">{</span>...<span class="s">}</span></code>
 are compile-time string
constants: you cannot use variables in them.  if you want similar
run-time functionality, use <code class="inline"><a class="l_k" href="functions/chr.html">chr()</a></code> and <code class="inline"><span class="i">charnames::vianame</span><span class="s">(</span><span class="s">)</span></code>
.</p>
<p>If you want to force the result to Unicode characters, use the special
<code class="inline"><span class="q">&quot;U0&quot;</span></code>
 prefix.  It consumes no arguments but forces the result to be
in Unicode characters, instead of bytes.</p>
<pre class="verbatim">   <a class="l_k" href="functions/my.html">my</a> <span class="i">$chars</span> = <a class="l_k" href="functions/pack.html">pack</a><span class="s">(</span><span class="q">&quot;U0C*&quot;</span><span class="cm">,</span> <span class="n">0x80</span><span class="cm">,</span> <span class="n">0x42</span><span class="s">)</span><span class="sc">;</span></pre>
<p>Likewise, you can force the result to be bytes by using the special
<code class="inline"><span class="q">&quot;C0&quot;</span></code>
 prefix.</p>
<a name="Handling-Unicode"></a><h2>Handling Unicode</h2>
<p>Handling Unicode is for the most part transparent: just use the
strings as usual.  Functions like <code class="inline"><a class="l_k" href="functions/index.html">index()</a></code>, <code class="inline"><a class="l_k" href="functions/length.html">length()</a></code>, and
<code class="inline"><a class="l_k" href="functions/substr.html">substr()</a></code> will work on the Unicode characters; regular expressions
will work on the Unicode characters (see <a href="perlunicode.html">perlunicode</a> and <a href="perlretut.html">perlretut</a>).</p>
<p>Note that Perl considers combining character sequences to be
separate characters, so for example</p>
<pre class="verbatim">    <a class="l_k" href="functions/use.html">use</a> <a class="l_w" href="charnames.html">charnames</a> <span class="q">&#39;:full&#39;</span><span class="sc">;</span>
    <a class="l_k" href="functions/print.html">print</a> <a class="l_k" href="functions/length.html">length</a><span class="s">(</span><span class="q">&quot;\N{LATIN CAPITAL LETTER A}\N{COMBINING ACUTE ACCENT}&quot;</span><span class="s">)</span><span class="cm">,</span> <span class="q">&quot;\n&quot;</span><span class="sc">;</span></pre>
<p>will print 2, not 1.  The only exception is that regular expressions
have <code class="inline">\X</code>
 for matching a combining character sequence.</p>
<p>Life is not quite so transparent, however, when working with legacy
encodings, I/O, and certain special cases:</p>
<a name="Legacy-Encodings"></a><h2>Legacy Encodings</h2>
<p>When you combine legacy data and Unicode the legacy data needs
to be upgraded to Unicode.  Normally ISO 8859-1 (or EBCDIC, if
applicable) is assumed.  You can override this assumption by
using the <code class="inline"><a class="l_w" href="encoding.html">encoding</a></code> pragma, for example</p>
<pre class="verbatim">    <a class="l_k" href="functions/use.html">use</a> <a class="l_w" href="encoding.html">encoding</a> <span class="q">&#39;latin2&#39;</span><span class="sc">;</span> <span class="c"># ISO 8859-2</span></pre>
<p>in which case literals (string or regular expressions), <code class="inline"><a class="l_k" href="functions/chr.html">chr()</a></code>,
and <code class="inline"><a class="l_k" href="functions/ord.html">ord()</a></code> in your whole script are assumed to produce Unicode
characters from ISO 8859-2 code points.  Note that the matching for
encoding names is forgiving: instead of <code class="inline">latin2</code>
 you could have
said <code class="inline">Latin <span class="n">2</span></code>
, or <code class="inline">iso8859-<span class="n">2</span></code>
, or other variations.  With just</p>
<pre class="verbatim">    <a class="l_k" href="functions/use.html">use</a> <a class="l_w" href="encoding.html">encoding</a><span class="sc">;</span></pre>
<p>the environment variable <code class="inline">PERL_ENCODING</code>
 will be consulted.
If that variable isn't set, the encoding pragma will fail.</p>
<p>The <code class="inline"><a class="l_w" href="Encode.html">Encode</a></code> module knows about many encodings and has interfaces
for doing conversions between those encodings:</p>
<pre class="verbatim">    <a class="l_k" href="functions/use.html">use</a> <a class="l_w" href="Encode.html">Encode</a> <span class="q">&#39;decode&#39;</span><span class="sc">;</span>
    <span class="i">$data</span> = <span class="i">decode</span><span class="s">(</span><span class="q">&quot;iso-8859-3&quot;</span><span class="cm">,</span> <span class="i">$data</span><span class="s">)</span><span class="sc">;</span> <span class="c"># convert from legacy to utf-8</span></pre>
<a name="Unicode-I%2fO"></a><h2>Unicode I/O</h2>
<p>Normally, writing out Unicode data</p>
<pre class="verbatim">    <a class="l_k" href="functions/print.html">print</a> <span class="i">FH</span> <span class="i">$some_string_with_unicode</span><span class="cm">,</span> <span class="q">&quot;\n&quot;</span><span class="sc">;</span></pre>
<p>produces raw bytes that Perl happens to use to internally encode the
Unicode string.  Perl's internal encoding depends on the system as
well as what characters happen to be in the string at the time. If
any of the characters are at code points <code class="inline"><span class="n">0x100</span></code>
 or above, you will get
a warning.  To ensure that the output is explicitly rendered in the
encoding you desire--and to avoid the warning--open the stream with
the desired encoding. Some examples:</p>
<pre class="verbatim">    <a class="l_k" href="functions/open.html">open</a> FH<span class="cm">,</span> <span class="q">&quot;&gt;:utf8&quot;</span><span class="cm">,</span> <span class="q">&quot;file&quot;</span><span class="sc">;</span></pre>
<pre class="verbatim">    <a class="l_k" href="functions/open.html">open</a> FH<span class="cm">,</span> <span class="q">&quot;&gt;:encoding(ucs2)&quot;</span><span class="cm">,</span>      <span class="q">&quot;file&quot;</span><span class="sc">;</span>
    <a class="l_k" href="functions/open.html">open</a> FH<span class="cm">,</span> <span class="q">&quot;&gt;:encoding(UTF-8)&quot;</span><span class="cm">,</span>     <span class="q">&quot;file&quot;</span><span class="sc">;</span>
    <a class="l_k" href="functions/open.html">open</a> FH<span class="cm">,</span> <span class="q">&quot;&gt;:encoding(shift_jis)&quot;</span><span class="cm">,</span> <span class="q">&quot;file&quot;</span><span class="sc">;</span></pre>
<p>and on already open streams, use <code class="inline"><a class="l_k" href="functions/binmode.html">binmode()</a></code>:</p>
<pre class="verbatim">    <a class="l_k" href="functions/binmode.html">binmode</a><span class="s">(</span>STDOUT<span class="cm">,</span> <span class="q">&quot;:utf8&quot;</span><span class="s">)</span><span class="sc">;</span></pre>
<pre class="verbatim">    <a class="l_k" href="functions/binmode.html">binmode</a><span class="s">(</span>STDOUT<span class="cm">,</span> <span class="q">&quot;:encoding(ucs2)&quot;</span><span class="s">)</span><span class="sc">;</span>
    <a class="l_k" href="functions/binmode.html">binmode</a><span class="s">(</span>STDOUT<span class="cm">,</span> <span class="q">&quot;:encoding(UTF-8)&quot;</span><span class="s">)</span><span class="sc">;</span>
    <a class="l_k" href="functions/binmode.html">binmode</a><span class="s">(</span>STDOUT<span class="cm">,</span> <span class="q">&quot;:encoding(shift_jis)&quot;</span><span class="s">)</span><span class="sc">;</span></pre>
<p>The matching of encoding names is loose: case does not matter, and
many encodings have several aliases.  Note that the <code class="inline"><span class="j">:</span><a class="l_w" href="utf8.html">utf8</a></code>
 layer
must always be specified exactly like that; it is <i>not</i> subject to
the loose matching of encoding names.</p>
<p>See <a href="PerlIO.html">PerlIO</a> for the <code class="inline"><span class="j">:</span><a class="l_w" href="utf8.html">utf8</a></code>
 layer, <a href="PerlIO/encoding.html">PerlIO::encoding</a> and
<a href="Encode/PerlIO.html">Encode::PerlIO</a> for the <code class="inline"><span class="j">:</span><span class="i">encoding</span><span class="s">(</span><span class="s">)</span></code>
 layer, and
<a href="Encode/Supported.html">Encode::Supported</a> for many encodings supported by the <code class="inline"><a class="l_w" href="Encode.html">Encode</a></code>
module.</p>
<p>Reading in a file that you know happens to be encoded in one of the
Unicode or legacy encodings does not magically turn the data into
Unicode in Perl's eyes.  To do that, specify the appropriate
layer when opening files</p>
<pre class="verbatim">    <a class="l_k" href="functions/open.html">open</a><span class="s">(</span><a class="l_k" href="functions/my.html">my</a> <span class="i">$fh</span><span class="cm">,</span><span class="q">&#39;&lt;:utf8&#39;</span><span class="cm">,</span> <span class="q">&#39;anything&#39;</span><span class="s">)</span><span class="sc">;</span>
    <a class="l_k" href="functions/my.html">my</a> <span class="i">$line_of_unicode</span> = <span class="q">&lt;$fh&gt;</span><span class="sc">;</span></pre>
<pre class="verbatim">    <a class="l_k" href="functions/open.html">open</a><span class="s">(</span><a class="l_k" href="functions/my.html">my</a> <span class="i">$fh</span><span class="cm">,</span><span class="q">&#39;&lt;:encoding(Big5)&#39;</span><span class="cm">,</span> <span class="q">&#39;anything&#39;</span><span class="s">)</span><span class="sc">;</span>
    <a class="l_k" href="functions/my.html">my</a> <span class="i">$line_of_unicode</span> = <span class="q">&lt;$fh&gt;</span><span class="sc">;</span></pre>
<p>The I/O layers can also be specified more flexibly with
the <code class="inline"><a class="l_k" href="functions/open.html">open</a></code> pragma.  See <a href="open.html">open</a>, or look at the following example.</p>
<pre class="verbatim">    <a class="l_k" href="functions/use.html">use</a> <a class="l_k" href="functions/open.html">open</a> <span class="q">&#39;:utf8&#39;</span><span class="sc">;</span> <span class="c"># input and output default layer will be UTF-8</span>
    <a class="l_k" href="functions/open.html">open</a> X<span class="cm">,</span> <span class="q">&quot;&gt;file&quot;</span><span class="sc">;</span>
    <a class="l_k" href="functions/print.html">print</a> <span class="i">X</span> <a class="l_k" href="functions/chr.html">chr</a><span class="s">(</span><span class="n">0x100</span><span class="s">)</span><span class="cm">,</span> <span class="q">&quot;\n&quot;</span><span class="sc">;</span>
    <a class="l_k" href="functions/close.html">close</a> X<span class="sc">;</span>
    <a class="l_k" href="functions/open.html">open</a> Y<span class="cm">,</span> <span class="q">&quot;&lt;file&quot;</span><span class="sc">;</span>
    <a class="l_k" href="functions/printf.html">printf</a> <span class="q">&quot;%#x\n&quot;</span><span class="cm">,</span> <a class="l_k" href="functions/ord.html">ord</a><span class="s">(</span><span class="q">&lt;Y&gt;</span><span class="s">)</span><span class="sc">;</span> <span class="c"># this should print 0x100</span>
    <a class="l_k" href="functions/close.html">close</a> Y<span class="sc">;</span></pre>
<p>With the <code class="inline"><a class="l_k" href="functions/open.html">open</a></code> pragma you can use the <code class="inline"><span class="j">:</span><a class="l_w" href="locale.html">locale</a></code>
 layer</p>
<pre class="verbatim">    BEGIN <span class="s">{</span> <span class="i">$ENV</span>{LC_ALL} = <span class="i">$ENV</span>{LANG} = <span class="q">&#39;ru_RU.KOI8-R&#39;</span> <span class="s">}</span>
    <span class="c"># the :locale will probe the locale environment variables like LC_ALL</span>
    <a class="l_k" href="functions/use.html">use</a> <a class="l_k" href="functions/open.html">open</a> OUT <span class="cm">=&gt;</span> <span class="q">&#39;:locale&#39;</span><span class="sc">;</span> <span class="c"># russki parusski</span>
    <a class="l_k" href="functions/open.html">open</a><span class="s">(</span><a class="l_w" href="O.html">O</a><span class="cm">,</span> <span class="q">&quot;&gt;koi8&quot;</span><span class="s">)</span><span class="sc">;</span>
    <a class="l_k" href="functions/print.html">print</a> <span class="i">O</span> <a class="l_k" href="functions/chr.html">chr</a><span class="s">(</span><span class="n">0x430</span><span class="s">)</span><span class="sc">;</span> <span class="c"># Unicode CYRILLIC SMALL LETTER A = KOI8-R 0xc1</span>
    <a class="l_k" href="functions/close.html">close</a> <a class="l_w" href="O.html">O</a><span class="sc">;</span>
    <a class="l_k" href="functions/open.html">open</a><span class="s">(</span>I<span class="cm">,</span> <span class="q">&quot;&lt;koi8&quot;</span><span class="s">)</span><span class="sc">;</span>
    <a class="l_k" href="functions/printf.html">printf</a> <span class="q">&quot;%#x\n&quot;</span><span class="cm">,</span> <a class="l_k" href="functions/ord.html">ord</a><span class="s">(</span><span class="q">&lt;I&gt;</span><span class="s">)</span><span class="cm">,</span> <span class="q">&quot;\n&quot;</span><span class="sc">;</span> <span class="c"># this should print 0xc1</span>
    <a class="l_k" href="functions/close.html">close</a> I<span class="sc">;</span></pre>
<p>or you can also use the <code class="inline"><span class="q">&#39;:encoding(...)&#39;</span></code>
 layer</p>
<pre class="verbatim">    <a class="l_k" href="functions/open.html">open</a><span class="s">(</span><a class="l_k" href="functions/my.html">my</a> <span class="i">$epic</span><span class="cm">,</span><span class="q">&#39;&lt;:encoding(iso-8859-7)&#39;</span><span class="cm">,</span><span class="q">&#39;iliad.greek&#39;</span><span class="s">)</span><span class="sc">;</span>
    <a class="l_k" href="functions/my.html">my</a> <span class="i">$line_of_unicode</span> = <span class="q">&lt;$epic&gt;</span><span class="sc">;</span></pre>
<p>These methods install a transparent filter on the I/O stream that
converts data from the specified encoding when it is read in from the
stream.  The result is always Unicode.</p>
<p>The <a href="open.html">open</a> pragma affects all the <code class="inline"><a class="l_k" href="functions/open.html">open()</a></code> calls after the pragma by
setting default layers.  If you want to affect only certain
streams, use explicit layers directly in the <code class="inline"><a class="l_k" href="functions/open.html">open()</a></code> call.</p>
<p>You can switch encodings on an already opened stream by using
<code class="inline"><a class="l_k" href="functions/binmode.html">binmode()</a></code>; see <a href="functions/binmode.html">binmode</a>.</p>
<p>The <code class="inline"><span class="j">:</span><a class="l_w" href="locale.html">locale</a></code>
 does not currently (as of Perl 5.8.0) work with
<code class="inline"><a class="l_k" href="functions/open.html">open()</a></code> and <code class="inline"><a class="l_k" href="functions/binmode.html">binmode()</a></code>, only with the <code class="inline"><a class="l_k" href="functions/open.html">open</a></code> pragma.  The
<code class="inline"><span class="j">:</span><a class="l_w" href="utf8.html">utf8</a></code>
 and <code class="inline"><span class="j">:</span><span class="i">encoding</span><span class="s">(</span>...<span class="s">)</span></code>
 methods do work with all of <code class="inline"><a class="l_k" href="functions/open.html">open()</a></code>,
<code class="inline"><a class="l_k" href="functions/binmode.html">binmode()</a></code>, and the <code class="inline"><a class="l_k" href="functions/open.html">open</a></code> pragma.</p>
<p>Similarly, you may use these I/O layers on output streams to
automatically convert Unicode to the specified encoding when it is
written to the stream. For example, the following snippet copies the
contents of the file "text.jis" (encoded as ISO-2022-JP, aka JIS) to
the file "text.utf8", encoded as UTF-8:</p>
<pre class="verbatim">    <a class="l_k" href="functions/open.html">open</a><span class="s">(</span><a class="l_k" href="functions/my.html">my</a> <span class="i">$nihongo</span><span class="cm">,</span> <span class="q">&#39;&lt;:encoding(iso-2022-jp)&#39;</span><span class="cm">,</span> <span class="q">&#39;text.jis&#39;</span><span class="s">)</span><span class="sc">;</span>
    <a class="l_k" href="functions/open.html">open</a><span class="s">(</span><a class="l_k" href="functions/my.html">my</a> <span class="i">$unicode</span><span class="cm">,</span> <span class="q">&#39;&gt;:utf8&#39;</span><span class="cm">,</span>                  <span class="q">&#39;text.utf8&#39;</span><span class="s">)</span><span class="sc">;</span>
    while <span class="s">(</span><span class="q">&lt;$nihongo&gt;</span><span class="s">)</span> <span class="s">{</span> <a class="l_k" href="functions/print.html">print</a> <span class="i">$unicode</span> <span class="i">$_</span> <span class="s">}</span></pre>
<p>The naming of encodings, both by the <code class="inline"><a class="l_k" href="functions/open.html">open()</a></code> and by the <code class="inline"><a class="l_k" href="functions/open.html">open</a></code>
pragma, is similar to the <code class="inline"><a class="l_w" href="encoding.html">encoding</a></code> pragma in that it allows for
flexible names: <code class="inline">koi8-r</code>
 and <code class="inline">KOI8R</code>
 will both be understood.</p>
<p>Common encodings recognized by ISO, MIME, IANA, and various other
standardisation organisations are recognised; for a more detailed
list see <a href="Encode/Supported.html">Encode::Supported</a>.</p>
<p><code class="inline"><a class="l_k" href="functions/read.html">read()</a></code> reads characters and returns the number of characters.
<code class="inline"><a class="l_k" href="functions/seek.html">seek()</a></code> and <code class="inline"><a class="l_k" href="functions/tell.html">tell()</a></code> operate on byte counts, as do <code class="inline"><a class="l_k" href="functions/sysread.html">sysread()</a></code>
and <code class="inline"><a class="l_k" href="functions/sysseek.html">sysseek()</a></code>.</p>
<p>Notice that because of the default behaviour of not doing any
conversion upon input if there is no default layer,
it is easy to mistakenly write code that keeps on expanding a file
by repeatedly encoding the data:</p>
<pre class="verbatim">    <span class="c"># BAD CODE WARNING</span>
    <a class="l_k" href="functions/open.html">open</a> F<span class="cm">,</span> <span class="q">&quot;file&quot;</span><span class="sc">;</span>
    <a class="l_k" href="functions/local.html">local</a> <span class="i">$/</span><span class="sc">;</span> <span class="c">## read in the whole file of 8-bit characters</span>
    <span class="i">$t</span> = <span class="q">&lt;F&gt;</span><span class="sc">;</span>
    <a class="l_k" href="functions/close.html">close</a> F<span class="sc">;</span>
    <a class="l_k" href="functions/open.html">open</a> F<span class="cm">,</span> <span class="q">&quot;&gt;:utf8&quot;</span><span class="cm">,</span> <span class="q">&quot;file&quot;</span><span class="sc">;</span>
    <a class="l_k" href="functions/print.html">print</a> <span class="i">F</span> <span class="i">$t</span><span class="sc">;</span> <span class="c">## convert to UTF-8 on output</span>
    <a class="l_k" href="functions/close.html">close</a> F<span class="sc">;</span></pre>
<p>If you run this code twice, the contents of the <i>file</i> will be twice
UTF-8 encoded.  A <code class="inline"><a class="l_k" href="functions/use.html">use</a> <a class="l_k" href="functions/open.html">open</a> <span class="q">&#39;:utf8&#39;</span></code>
 would have avoided the bug, or
explicitly opening also the <i>file</i> for input as UTF-8.</p>
<p><b>NOTE</b>: the <code class="inline"><span class="j">:</span><a class="l_w" href="utf8.html">utf8</a></code>
 and <code class="inline"><span class="j">:</span><a class="l_w" href="encoding.html">encoding</a></code>
 features work only if your
Perl has been built with the new PerlIO feature (which is the default
on most systems).</p>
<a name="Displaying-Unicode-As-Text"></a><h2>Displaying Unicode As Text</h2>
<p>Sometimes you might want to display Perl scalars containing Unicode as
simple ASCII (or EBCDIC) text.  The following subroutine converts
its argument so that Unicode characters with code points greater than
255 are displayed as <code class="inline">\<span class="i">x</span><span class="s">{</span>...<span class="s">}</span></code>
, control characters (like <code class="inline">\n</code>
) are
displayed as <code class="inline">\x..</code>
, and the rest of the characters as themselves:</p>
<pre class="verbatim"><a name="nice_string"></a>   sub <span class="m">nice_string</span> <span class="s">{</span>
       <a class="l_k" href="functions/join.html">join</a><span class="s">(</span><span class="q">&quot;&quot;</span><span class="cm">,</span>
         <a class="l_k" href="functions/map.html">map</a> <span class="s">{</span> <span class="i">$_</span> &gt; <span class="n">255</span> ?                  <span class="c"># if wide character...</span>
               <a class="l_k" href="functions/sprintf.html">sprintf</a><span class="s">(</span><span class="q">&quot;\\x{%04X}&quot;</span><span class="cm">,</span> <span class="i">$_</span><span class="s">)</span> <span class="co">:</span>  <span class="c"># \x{...}</span>
               <a class="l_k" href="functions/chr.html">chr</a><span class="s">(</span><span class="i">$_</span><span class="s">)</span> =~ <span class="q">/[[:cntrl:]]/</span> ?  <span class="c"># else if control character ...</span>
               <a class="l_k" href="functions/sprintf.html">sprintf</a><span class="s">(</span><span class="q">&quot;\\x%02X&quot;</span><span class="cm">,</span> <span class="i">$_</span><span class="s">)</span> <span class="co">:</span>    <span class="c"># \x..</span>
               <a class="l_k" href="functions/quotemeta.html">quotemeta</a><span class="s">(</span><a class="l_k" href="functions/chr.html">chr</a><span class="s">(</span><span class="i">$_</span><span class="s">)</span><span class="s">)</span>          <span class="c"># else quoted or as themselves</span>
         <span class="s">}</span> <a class="l_k" href="functions/unpack.html">unpack</a><span class="s">(</span><span class="q">&quot;U*&quot;</span><span class="cm">,</span> <span class="i">$_</span>[<span class="n">0</span>]<span class="s">)</span><span class="s">)</span><span class="sc">;</span>           <span class="c"># unpack Unicode characters</span>
   <span class="s">}</span></pre>
<p>For example,</p>
<pre class="verbatim">   <span class="i">nice_string</span><span class="s">(</span><span class="q">&quot;foo\x{100}bar\n&quot;</span><span class="s">)</span></pre>
<p>returns the string</p>
<pre class="verbatim">   <span class="q">&#39;foo\x{0100}bar\x0A&#39;</span></pre>
<p>which is ready to be printed.</p>
<a name="Special-Cases"></a><h2>Special Cases</h2>
<ul>
<li>
<p>Bit Complement Operator ~ And vec()</p>
<p>The bit complement operator <code class="inline">~</code>
 may produce surprising results if
used on strings containing characters with ordinal values above
255. In such a case, the results are consistent with the internal
encoding of the characters, but not with much else. So don't do
that. Similarly for <code class="inline"><a class="l_k" href="functions/vec.html">vec()</a></code>: you will be operating on the
internally-encoded bit patterns of the Unicode characters, not on
the code point values, which is very probably not what you want.</p>
</li>
<li>
<p>Peeking At Perl's Internal Encoding</p>
<p>Normal users of Perl should never care how Perl encodes any particular
Unicode string (because the normal ways to get at the contents of a
string with Unicode--via input and output--should always be via
explicitly-defined I/O layers). But if you must, there are two
ways of looking behind the scenes.</p>
<p>One way of peeking inside the internal encoding of Unicode characters
is to use <code class="inline">unpack("C*", ...</code> to get the bytes or <code class="inline"><a class="l_k" href="functions/unpack.html">unpack</a><span class="s">(</span><span class="q">&quot;H*&quot;</span><span class="cm">,</span> ...<span class="s">)</span></code>

to display the bytes:</p>
<pre class="verbatim">    <span class="c"># this prints  c4 80  for the UTF-8 bytes 0xc4 0x80</span>
    <a class="l_k" href="functions/print.html">print</a> <a class="l_k" href="functions/join.html">join</a><span class="s">(</span><span class="q">&quot; &quot;</span><span class="cm">,</span> <a class="l_k" href="functions/unpack.html">unpack</a><span class="s">(</span><span class="q">&quot;H*&quot;</span><span class="cm">,</span> <a class="l_k" href="functions/pack.html">pack</a><span class="s">(</span><span class="q">&quot;U&quot;</span><span class="cm">,</span> <span class="n">0x100</span><span class="s">)</span><span class="s">)</span><span class="s">)</span><span class="cm">,</span> <span class="q">&quot;\n&quot;</span><span class="sc">;</span></pre>
<p>Yet another way would be to use the Devel::Peek module:</p>
<pre class="verbatim">    perl -MDevel::Peek -e <span class="q">&#39;Dump(chr(0x100))&#39;</span></pre>
<p>That shows the <code class="inline">UTF8</code>
 flag in FLAGS and both the UTF-8 bytes
and Unicode characters in <code class="inline">PV</code>
.  See also later in this document
the discussion about the <code class="inline"><span class="i">utf8::is_utf8</span><span class="s">(</span><span class="s">)</span></code>
 function.</p>
</li>
</ul>
<a name="Advanced-Topics"></a><h2>Advanced Topics</h2>
<ul>
<li>
<p>String Equivalence</p>
<p>The question of string equivalence turns somewhat complicated
in Unicode: what do you mean by "equal"?</p>
<p>(Is <code class="inline">LATIN CAPITAL LETTER A WITH ACUTE</code>
 equal to
<code class="inline">LATIN CAPITAL LETTER A</code>
?)</p>
<p>The short answer is that by default Perl compares equivalence (<code class="inline">eq</code>
,
<code class="inline">ne</code>
) based only on code points of the characters.  In the above
case, the answer is no (because 0x00C1 != 0x0041).  But sometimes, any
CAPITAL LETTER As should be considered equal, or even As of any case.</p>
<p>The long answer is that you need to consider character normalization
and casing issues: see <a href="Unicode/Normalize.html">Unicode::Normalize</a>, Unicode Technical
Reports #15 and #21, <i>Unicode Normalization Forms</i> and <i>Case
Mappings</i>, <a href="http://www.unicode.org/unicode/reports/tr15/">http://www.unicode.org/unicode/reports/tr15/</a> and 
<a href="http://www.unicode.org/unicode/reports/tr21/">http://www.unicode.org/unicode/reports/tr21/</a> </p>
<p>As of Perl 5.8.0, the "Full" case-folding of <i>Case
Mappings/SpecialCasing</i> is implemented.</p>
</li>
<li>
<p>String Collation</p>
<p>People like to see their strings nicely sorted--or as Unicode
parlance goes, collated.  But again, what do you mean by collate?</p>
<p>(Does <code class="inline">LATIN CAPITAL LETTER A WITH ACUTE</code>
 come before or after
<code class="inline">LATIN CAPITAL LETTER A WITH GRAVE</code>
?)</p>
<p>The short answer is that by default, Perl compares strings (<code class="inline">lt</code>
,
<code class="inline">le</code>
, <code class="inline">cmp</code>
, <code class="inline">ge</code>
, <code class="inline">gt</code>
) based only on the code points of the
characters.  In the above case, the answer is "after", since
<code class="inline"><span class="n">0x00C1</span></code>
 &gt; <code class="inline"><span class="n">0x00C0</span></code>
.</p>
<p>The long answer is that "it depends", and a good answer cannot be
given without knowing (at the very least) the language context.
See <a href="Unicode/Collate.html">Unicode::Collate</a>, and <i>Unicode Collation Algorithm</i>
<a href="http://www.unicode.org/unicode/reports/tr10/">http://www.unicode.org/unicode/reports/tr10/</a></p>
</li>
</ul>
<a name="Miscellaneous"></a><h2>Miscellaneous</h2>
<ul>
<li>
<p>Character Ranges and Classes</p>
<p>Character ranges in regular expression character classes (<code class="inline"><span class="q">/[a-z]/</span></code>
)
and in the <code class="inline"><a class="l_k" href="functions/tr.html">tr///</a></code> (also known as <code class="inline"><a class="l_k" href="functions/y.html">y///</a></code>) operator are not magically
Unicode-aware.  What this means that <code class="inline"><span class="s">[</span>A-Za-z<span class="s">]</span></code>
 will not magically start
to mean "all alphabetic letters"; not that it does mean that even for
8-bit characters, you should be using <code class="inline"><span class="q">/[[:alpha:]]/</span></code>
 in that case.</p>
<p>For specifying character classes like that in regular expressions,
you can use the various Unicode properties--<code class="inline">\pL</code>
, or perhaps
<code class="inline">\<span class="i">p</span><span class="s">{</span>Alphabetic<span class="s">}</span></code>
, in this particular case.  You can use Unicode
code points as the end points of character ranges, but there is no
magic associated with specifying a certain range.  For further
information--there are dozens of Unicode character classes--see
<a href="perlunicode.html">perlunicode</a>.</p>
</li>
<li>
<p>String-To-Number Conversions</p>
<p>Unicode does define several other decimal--and numeric--characters
besides the familiar 0 to 9, such as the Arabic and Indic digits.
Perl does not support string-to-number conversion for digits other
than ASCII 0 to 9 (and ASCII a to f for hexadecimal).</p>
</li>
</ul>
<a name="Questions-With-Answers"></a><h2>Questions With Answers</h2>
<ul>
<li>
<p>Will My Old Scripts Break?</p>
<p>Very probably not.  Unless you are generating Unicode characters
somehow, old behaviour should be preserved.  About the only behaviour
that has changed and which could start generating Unicode is the old
behaviour of <code class="inline"><a class="l_k" href="functions/chr.html">chr()</a></code> where supplying an argument more than 255
produced a character modulo 255.  <code class="inline"><a class="l_k" href="functions/chr.html">chr(300)</a></code>, for example, was equal
to <code class="inline"><a class="l_k" href="functions/chr.html">chr(45)</a></code> or "-" (in ASCII), now it is LATIN CAPITAL LETTER I WITH
BREVE.</p>
</li>
<li>
<p>How Do I Make My Scripts Work With Unicode?</p>
<p>Very little work should be needed since nothing changes until you
generate Unicode data.  The most important thing is getting input as
Unicode; for that, see the earlier I/O discussion.</p>
</li>
<li>
<p>How Do I Know Whether My String Is In Unicode?</p>
<p>You shouldn't care.  No, you really shouldn't.  No, really.  If you
have to care--beyond the cases described above--it means that we
didn't get the transparency of Unicode quite right.</p>
<p>Okay, if you insist:</p>
<pre class="verbatim">    <a class="l_k" href="functions/print.html">print</a> <span class="i">utf8::is_utf8</span><span class="s">(</span><span class="i">$string</span><span class="s">)</span> ? <span class="n">1</span> <span class="co">:</span> <span class="n">0</span><span class="cm">,</span> <span class="q">&quot;\n&quot;</span><span class="sc">;</span></pre>
<p>But note that this doesn't mean that any of the characters in the
string are necessary UTF-8 encoded, or that any of the characters have
code points greater than 0xFF (255) or even 0x80 (128), or that the
string has any characters at all.  All the <code class="inline"><span class="i">is_utf8</span><span class="s">(</span><span class="s">)</span></code>
 does is to
return the value of the internal "utf8ness" flag attached to the
<code class="inline"><span class="i">$string</span></code>
.  If the flag is off, the bytes in the scalar are interpreted
as a single byte encoding.  If the flag is on, the bytes in the scalar
are interpreted as the (multi-byte, variable-length) UTF-8 encoded code
points of the characters.  Bytes added to an UTF-8 encoded string are
automatically upgraded to UTF-8.  If mixed non-UTF-8 and UTF-8 scalars
are merged (double-quoted interpolation, explicit concatenation, and
printf/sprintf parameter substitution), the result will be UTF-8 encoded
as if copies of the byte strings were upgraded to UTF-8: for example,</p>
<pre class="verbatim">    <span class="i">$a</span> = <span class="q">&quot;ab\x80c&quot;</span><span class="sc">;</span>
    <span class="i">$b</span> = <span class="q">&quot;\x{100}&quot;</span><span class="sc">;</span>
    <a class="l_k" href="functions/print.html">print</a> <span class="q">&quot;$a = $b\n&quot;</span><span class="sc">;</span></pre>
<p>the output string will be UTF-8-encoded <code class="inline">ab\x80c = \<span class="i">x</span><span class="s">{</span><span class="n">100</span><span class="s">}</span>\n</code>
, but
<code class="inline"><span class="i">$a</span></code>
 will stay byte-encoded.</p>
<p>Sometimes you might really need to know the byte length of a string
instead of the character length. For that use either the
<code class="inline"><span class="i">Encode::encode_utf8</span><span class="s">(</span><span class="s">)</span></code>
 function or the <code class="inline"><a class="l_w" href="bytes.html">bytes</a></code> pragma and its only
defined function <code class="inline"><a class="l_k" href="functions/length.html">length()</a></code>:</p>
<pre class="verbatim">    <a class="l_k" href="functions/my.html">my</a> <span class="i">$unicode</span> = <a class="l_k" href="functions/chr.html">chr</a><span class="s">(</span><span class="n">0x100</span><span class="s">)</span><span class="sc">;</span>
    <a class="l_k" href="functions/print.html">print</a> <a class="l_k" href="functions/length.html">length</a><span class="s">(</span><span class="i">$unicode</span><span class="s">)</span><span class="cm">,</span> <span class="q">&quot;\n&quot;</span><span class="sc">;</span> <span class="c"># will print 1</span>
    <a class="l_k" href="functions/require.html">require</a> <a class="l_w" href="Encode.html">Encode</a><span class="sc">;</span>
    <a class="l_k" href="functions/print.html">print</a> <a class="l_k" href="functions/length.html">length</a><span class="s">(</span><span class="i">Encode::encode_utf8</span><span class="s">(</span><span class="i">$unicode</span><span class="s">)</span><span class="s">)</span><span class="cm">,</span> <span class="q">&quot;\n&quot;</span><span class="sc">;</span> <span class="c"># will print 2</span>
    <a class="l_k" href="functions/use.html">use</a> <a class="l_w" href="bytes.html">bytes</a><span class="sc">;</span>
    <a class="l_k" href="functions/print.html">print</a> <a class="l_k" href="functions/length.html">length</a><span class="s">(</span><span class="i">$unicode</span><span class="s">)</span><span class="cm">,</span> <span class="q">&quot;\n&quot;</span><span class="sc">;</span> <span class="c"># will also print 2</span>
                                  <span class="c"># (the 0xC4 0x80 of the UTF-8)</span></pre>
</li>
<li>
<p>How Do I Detect Data That's Not Valid In a Particular Encoding?</p>
<p>Use the <code class="inline"><a class="l_w" href="Encode.html">Encode</a></code> package to try converting it.
For example,</p>
<pre class="verbatim">    <a class="l_k" href="functions/use.html">use</a> <a class="l_w" href="Encode.html">Encode</a> <span class="q">&#39;decode_utf8&#39;</span><span class="sc">;</span>
    if <span class="s">(</span><span class="i">decode_utf8</span><span class="s">(</span><span class="i">$string_of_bytes_that_I_think_is_utf8</span><span class="s">)</span><span class="s">)</span> <span class="s">{</span>
        <span class="c"># valid</span>
    <span class="s">}</span> else <span class="s">{</span>
        <span class="c"># invalid</span>
    <span class="s">}</span></pre>
<p>For UTF-8 only, you can use:</p>
<pre class="verbatim">    <a class="l_k" href="functions/use.html">use</a> <a class="l_w" href="warnings.html">warnings</a><span class="sc">;</span>
    <span class="i">@chars</span> = <a class="l_k" href="functions/unpack.html">unpack</a><span class="s">(</span><span class="q">&quot;U0U*&quot;</span><span class="cm">,</span> <span class="i">$string_of_bytes_that_I_think_is_utf8</span><span class="s">)</span><span class="sc">;</span></pre>
<p>If invalid, a <code class="inline">Malformed UTF-8 character (byte 0x##) in unpack</code>
warning is produced. The "U0" means "expect strictly UTF-8 encoded
Unicode".  Without that the <code class="inline"><a class="l_k" href="functions/unpack.html">unpack</a><span class="s">(</span><span class="q">&quot;U*&quot;</span><span class="cm">,</span> ...<span class="s">)</span></code>
 would accept also
data like <code class="inline"><a class="l_k" href="functions/chr.html">chr(0xFF</a></code>), similarly to the <code class="inline"><a class="l_k" href="functions/pack.html">pack</a></code> as we saw earlier.</p>
</li>
<li>
<p>How Do I Convert Binary Data Into a Particular Encoding, Or Vice Versa?</p>
<p>This probably isn't as useful as you might think.
Normally, you shouldn't need to.</p>
<p>In one sense, what you are asking doesn't make much sense: encodings
are for characters, and binary data are not "characters", so converting
"data" into some encoding isn't meaningful unless you know in what
character set and encoding the binary data is in, in which case it's
not just binary data, now is it?</p>
<p>If you have a raw sequence of bytes that you know should be
interpreted via a particular encoding, you can use <code class="inline"><a class="l_w" href="Encode.html">Encode</a></code>:</p>
<pre class="verbatim">    <a class="l_k" href="functions/use.html">use</a> <a class="l_w" href="Encode.html">Encode</a> <span class="q">&#39;from_to&#39;</span><span class="sc">;</span>
    <span class="i">from_to</span><span class="s">(</span><span class="i">$data</span><span class="cm">,</span> <span class="q">&quot;iso-8859-1&quot;</span><span class="cm">,</span> <span class="q">&quot;utf-8&quot;</span><span class="s">)</span><span class="sc">;</span> <span class="c"># from latin-1 to utf-8</span></pre>
<p>The call to <code class="inline"><span class="i">from_to</span><span class="s">(</span><span class="s">)</span></code>
 changes the bytes in <code class="inline"><span class="i">$data</span></code>
, but nothing
material about the nature of the string has changed as far as Perl is
concerned.  Both before and after the call, the string <code class="inline"><span class="i">$data</span></code>

contains just a bunch of 8-bit bytes. As far as Perl is concerned,
the encoding of the string remains as "system-native 8-bit bytes".</p>
<p>You might relate this to a fictional 'Translate' module:</p>
<pre class="verbatim">   <a class="l_k" href="functions/use.html">use</a> Translate<span class="sc">;</span>
   <a class="l_k" href="functions/my.html">my</a> <span class="i">$phrase</span> = <span class="q">&quot;Yes&quot;</span><span class="sc">;</span>
   <span class="i">Translate::from_to</span><span class="s">(</span><span class="i">$phrase</span><span class="cm">,</span> <span class="q">&#39;english&#39;</span><span class="cm">,</span> <span class="q">&#39;deutsch&#39;</span><span class="s">)</span><span class="sc">;</span>
   <span class="c">## phrase now contains &quot;Ja&quot;</span></pre>
<p>The contents of the string changes, but not the nature of the string.
Perl doesn't know any more after the call than before that the
contents of the string indicates the affirmative.</p>
<p>Back to converting data.  If you have (or want) data in your system's
native 8-bit encoding (e.g. Latin-1, EBCDIC, etc.), you can use
pack/unpack to convert to/from Unicode.</p>
<pre class="verbatim">    <span class="i">$native_string</span>  = <a class="l_k" href="functions/pack.html">pack</a><span class="s">(</span><span class="q">&quot;C*&quot;</span><span class="cm">,</span> <a class="l_k" href="functions/unpack.html">unpack</a><span class="s">(</span><span class="q">&quot;U*&quot;</span><span class="cm">,</span> <span class="i">$Unicode_string</span><span class="s">)</span><span class="s">)</span><span class="sc">;</span>
    <span class="i">$Unicode_string</span> = <a class="l_k" href="functions/pack.html">pack</a><span class="s">(</span><span class="q">&quot;U*&quot;</span><span class="cm">,</span> <a class="l_k" href="functions/unpack.html">unpack</a><span class="s">(</span><span class="q">&quot;C*&quot;</span><span class="cm">,</span> <span class="i">$native_string</span><span class="s">)</span><span class="s">)</span><span class="sc">;</span></pre>
<p>If you have a sequence of bytes you <b>know</b> is valid UTF-8,
but Perl doesn't know it yet, you can make Perl a believer, too:</p>
<pre class="verbatim">    <a class="l_k" href="functions/use.html">use</a> <a class="l_w" href="Encode.html">Encode</a> <span class="q">&#39;decode_utf8&#39;</span><span class="sc">;</span>
    <span class="i">$Unicode</span> = <span class="i">decode_utf8</span><span class="s">(</span><span class="i">$bytes</span><span class="s">)</span><span class="sc">;</span></pre>
<p>You can convert well-formed UTF-8 to a sequence of bytes, but if
you just want to convert random binary data into UTF-8, you can't.
<b>Any random collection of bytes isn't well-formed UTF-8</b>.  You can
use <code class="inline"><a class="l_k" href="functions/unpack.html">unpack</a><span class="s">(</span><span class="q">&quot;C*&quot;</span><span class="cm">,</span> <span class="i">$string</span><span class="s">)</span></code>
 for the former, and you can create
well-formed Unicode data by <code class="inline"><a class="l_k" href="functions/pack.html">pack</a><span class="s">(</span><span class="q">&quot;U*&quot;</span><span class="cm">,</span> <span class="n">0xff</span><span class="cm">,</span> ...<span class="s">)</span></code>
.</p>
</li>
<li>
<p>How Do I Display Unicode?  How Do I Input Unicode?</p>
<p>See <a href="http://www.alanwood.net/unicode/">http://www.alanwood.net/unicode/</a> and
<a href="http://www.cl.cam.ac.uk/~mgk25/unicode.html">http://www.cl.cam.ac.uk/~mgk25/unicode.html</a></p>
</li>
<li>
<p>How Does Unicode Work With Traditional Locales?</p>
<p>In Perl, not very well.  Avoid using locales through the <code class="inline"><a class="l_w" href="locale.html">locale</a></code>
pragma.  Use only one or the other.  But see <a href="perlrun.html">perlrun</a> for the
description of the <code class="inline">-C</code>
 switch and its environment counterpart,
<code class="inline"><span class="i">$ENV</span>{PERL_UNICODE}</code>
 to see how to enable various Unicode features,
for example by using locale settings.</p>
</li>
</ul>
<a name="Hexadecimal-Notation"></a><h2>Hexadecimal Notation</h2>
<p>The Unicode standard prefers using hexadecimal notation because
that more clearly shows the division of Unicode into blocks of 256 characters.
Hexadecimal is also simply shorter than decimal.  You can use decimal
notation, too, but learning to use hexadecimal just makes life easier
with the Unicode standard.  The <code class="inline">U+HHHH</code>
 notation uses hexadecimal,
for example.</p>
<p>The <code class="inline"><span class="n">0</span>x</code>
 prefix means a hexadecimal number, the digits are 0-9 <i>and</i>
a-f (or A-F, case doesn't matter).  Each hexadecimal digit represents
four bits, or half a byte.  <code class="inline"><a class="l_k" href="functions/print.html">print</a> <span class="n">0</span>x...<span class="cm">,</span> <span class="q">&quot;\n&quot;</span></code>
 will show a
hexadecimal number in decimal, and <code class="inline"><a class="l_k" href="functions/printf.html">printf</a> <span class="q">&quot;%x\n&quot;</span><span class="cm">,</span> <span class="i">$decimal</span></code>
 will
show a decimal number in hexadecimal.  If you have just the
"hex digits" of a hexadecimal number, you can use the <code class="inline"><a class="l_k" href="functions/hex.html">hex()</a></code> function.</p>
<pre class="verbatim">    <a class="l_k" href="functions/print.html">print</a> <span class="n">0x0009</span><span class="cm">,</span> <span class="q">&quot;\n&quot;</span><span class="sc">;</span>    <span class="c"># 9</span>
    <a class="l_k" href="functions/print.html">print</a> <span class="n">0x000a</span><span class="cm">,</span> <span class="q">&quot;\n&quot;</span><span class="sc">;</span>    <span class="c"># 10</span>
    <a class="l_k" href="functions/print.html">print</a> <span class="n">0x000f</span><span class="cm">,</span> <span class="q">&quot;\n&quot;</span><span class="sc">;</span>    <span class="c"># 15</span>
    <a class="l_k" href="functions/print.html">print</a> <span class="n">0x0010</span><span class="cm">,</span> <span class="q">&quot;\n&quot;</span><span class="sc">;</span>    <span class="c"># 16</span>
    <a class="l_k" href="functions/print.html">print</a> <span class="n">0x0011</span><span class="cm">,</span> <span class="q">&quot;\n&quot;</span><span class="sc">;</span>    <span class="c"># 17</span>
    <a class="l_k" href="functions/print.html">print</a> <span class="n">0x0100</span><span class="cm">,</span> <span class="q">&quot;\n&quot;</span><span class="sc">;</span>    <span class="c"># 256</span></pre>
<pre class="verbatim">    <a class="l_k" href="functions/print.html">print</a> <span class="n">0x0041</span><span class="cm">,</span> <span class="q">&quot;\n&quot;</span><span class="sc">;</span>    <span class="c"># 65</span></pre>
<pre class="verbatim">    <a class="l_k" href="functions/printf.html">printf</a> <span class="q">&quot;%x\n&quot;</span><span class="cm">,</span>  <span class="n">65</span><span class="sc">;</span>    <span class="c"># 41</span>
    <a class="l_k" href="functions/printf.html">printf</a> <span class="q">&quot;%#x\n&quot;</span><span class="cm">,</span> <span class="n">65</span><span class="sc">;</span>    <span class="c"># 0x41</span></pre>
<pre class="verbatim">    <a class="l_k" href="functions/print.html">print</a> <a class="l_k" href="functions/hex.html">hex</a><span class="s">(</span><span class="q">&quot;41&quot;</span><span class="s">)</span><span class="cm">,</span> <span class="q">&quot;\n&quot;</span><span class="sc">;</span> <span class="c"># 65</span></pre>
<a name="Further-Resources"></a><h2>Further Resources</h2>
<ul>
<li>
<p>Unicode Consortium</p>
<pre class="verbatim">    http://www.unicode.org/</pre></li>
<li>
<p>Unicode FAQ</p>
<pre class="verbatim">    http://www.unicode.org/unicode/faq/</pre></li>
<li>
<p>Unicode Glossary</p>
<pre class="verbatim">    http://www.unicode.org/glossary/</pre></li>
<li>
<p>Unicode Useful Resources</p>
<pre class="verbatim">    http://www.unicode.org/unicode/onlinedat/resources.html</pre></li>
<li>
<p>Unicode and Multilingual Support in HTML, Fonts, Web Browsers and Other Applications</p>
<pre class="verbatim">    http://www.alanwood.net/unicode/</pre></li>
<li>
<p>UTF-8 and Unicode FAQ for Unix/Linux</p>
<pre class="verbatim">    http://www.cl.cam.ac.uk/~mgk25/unicode.html</pre></li>
<li>
<p>Legacy Character Sets</p>
<pre class="verbatim">    http://www.czyborra.com/
    http://www.eki.ee/letter/</pre></li>
<li>
<p>The Unicode support files live within the Perl installation in the
directory</p>
<pre class="verbatim">    <span class="i">$Config</span>{installprivlib}/unicore</pre>
<p>in Perl 5.8.0 or newer, and </p>
<pre class="verbatim">    <span class="i">$Config</span>{installprivlib}/unicode</pre>
<p>in the Perl 5.6 series.  (The renaming to <i>lib/unicore</i> was done to
avoid naming conflicts with lib/Unicode in case-insensitive filesystems.)
The main Unicode data file is <i>UnicodeData.txt</i> (or <i>Unicode.301</i> in
Perl 5.6.1.)  You can find the <code class="inline"><span class="i">$Config</span>{installprivlib}</code>
 by</p>
<pre class="verbatim">    perl <span class="q">&quot;-V:installprivlib&quot;</span></pre>
<p>You can explore various information from the Unicode data files using
the <code class="inline"><a class="l_w" href="Unicode/UCD.html">Unicode::UCD</a></code> module.</p>
</li>
</ul>
<a name="UNICODE-IN-OLDER-PERLS"></a><h1>UNICODE IN OLDER PERLS</h1>
<p>If you cannot upgrade your Perl to 5.8.0 or later, you can still
do some Unicode processing by using the modules <code class="inline">Unicode::String</code>
,
<code class="inline">Unicode::Map8</code>
, and <code class="inline">Unicode::Map</code>
, available from CPAN.
If you have the GNU recode installed, you can also use the
Perl front-end <code class="inline">Convert::Recode</code>
 for character conversions.</p>
<p>The following are fast conversions from ISO 8859-1 (Latin-1) bytes
to UTF-8 bytes and back, the code works even with older Perl 5 versions.</p>
<pre class="verbatim">    <span class="c"># ISO 8859-1 to UTF-8</span>
    <span class="q">s/([\x80-\xFF])/chr(0xC0|ord($1)&gt;&gt;6).chr(0x80|ord($1)&amp;0x3F)/eg</span><span class="sc">;</span></pre>
<pre class="verbatim">    <span class="c"># UTF-8 to ISO 8859-1</span>
    <span class="q">s/([\xC2\xC3])([\x80-\xBF])/chr(ord($1)&lt;&lt;6&amp;0xC0|ord($2)&amp;0x3F)/eg</span><span class="sc">;</span></pre>
<a name="SEE-ALSO"></a><h1>SEE ALSO</h1>
<p><a href="perlunicode.html">perlunicode</a>, <a href="Encode.html">Encode</a>, <a href="encoding.html">encoding</a>, <a href="open.html">open</a>, <a href="utf8.html">utf8</a>, <a href="bytes.html">bytes</a>,
<a href="perlretut.html">perlretut</a>, <a href="perlrun.html">perlrun</a>, <a href="Unicode/Collate.html">Unicode::Collate</a>, <a href="Unicode/Normalize.html">Unicode::Normalize</a>,
<a href="Unicode/UCD.html">Unicode::UCD</a></p>
<a name="ACKNOWLEDGMENTS"></a><h1>ACKNOWLEDGMENTS</h1>
<p>Thanks to the kind readers of the perl5-porters@perl.org,
perl-unicode@perl.org, linux-utf8@nl.linux.org, and unicore@unicode.org
mailing lists for their valuable feedback.</p>
<a name="AUTHOR%2c-COPYRIGHT%2c-AND-LICENSE"></a><h1>AUTHOR, COPYRIGHT, AND LICENSE</h1>
<p>Copyright 2001-2002 Jarkko Hietaniemi &lt;jhi@iki.fi&gt;</p>
<p>This document may be distributed under the same terms as Perl itself.</p>
</div>
      <div id="contentFooter"><a href="http://www.perl.org"><img src="perlpowered.png" border=0></a></div>
    </div>
  </div>

  <div id="right">
    <div id="rightContent">
      <div id="leftClose">
        <a href="#" onClick="closeRight()" title="Hide toolbar" onmouseover="rightCloseIcon.src='close_purple.gif';" onmouseout="rightCloseIcon.src='close_blue.gif';"><img src="close_blue.gif" name="rightCloseIcon" id="rightCloseIcon" border=0></a>
      </div>
      <h1>Search:</h1>
      <p>
        <form action="search.html" name="perldoc_search">
	  <input type="text" name="q" size="10" class="grey"><br>
	  <!--<select name="r"><option value="1" selected>Go to top result<option value="0">Show results list</select>-->
	</form>
      </p>
      <h2>Labels:</h2>
      <p>
        <a href="#" onClick="addLabel('perluniintro','perluniintro.html')">Add this page</a>
      </p>
      <div class="labels" id="labels">
      </div>
    </div>
  </div>

</div>

</body>
</html>
